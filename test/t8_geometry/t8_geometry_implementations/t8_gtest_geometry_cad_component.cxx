/*
  This file is part of t8code.
  t8code is a C library to manage a collection (a forest) of multiple
  connected adaptive space-trees of general element classes in parallel.

  Copyright (C) 2026 the developers

  t8code is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  t8code is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with t8code; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/

/** \file t8_gtest_geometry_cad_component.cxx
  * Provides a component test for the curved cad geometry. The component test
  * not only checks the geometry implementations, but the whole pipeline including
  * the curved mesh reader.
  * The Test compares two different meshes for each implemented (and testable) eclasses.
  * In this case triangles, quads, hexes and tets. Meshes with pyramids and prisms are hard
  * to generate with Gmsh.
  * For each eclass there are two meshes and a cad file. One curved mesh with its cad file and
  * a target mesh. So a mesh which should be equal to the curved mesh if it was refined by one level.
  * The target meshes were created with the refine by splitting function by Gmsh. This function
  * also maps the new nodes onto the cad shape, but uses a different algorithm for that. Therefore,
  * the meshes are also geometry-refined, but have slightly different coordinates. This is
  * the reason for the high tolerance in this test.
  *
  * For tets we do not have a Gmsh-refined mesh since Gmsh splits its meshes differently
  * as t8code. Her we have a manually checked vtu file generated by t8code.
  */

#include <gtest/gtest.h>
#include <test/t8_gtest_macros.hxx>
#include <test/t8_gtest_custom_assertion.hxx>

#include <t8_cmesh/t8_cmesh.hxx>
#include <t8_forest/t8_forest_general.h>
#include <t8_schemes/t8_scheme.hxx>
#include <t8_cmesh/t8_cmesh_io/t8_cmesh_readmshfile.h>
#include <t8_eclass.h>
#include <t8_forest/t8_forest_iterate.h>
#include <src/t8_vtk/t8_with_vtk/t8_vtk_reader.hxx>

#include <string>
#include <array>
#include <vector>
#include <span>
#include <numeric>
#include <algorithm>

enum test_filetype { VTK_FILE, MSH_FILE };

inline constexpr int num_testfiles = 5;
inline constexpr std::array<std::string_view, num_testfiles> test_files
  = { "cad_component_quad", "cad_component_tri", "cad_component_hybrid2d", "cad_component_hex", "cad_component_tet" };
inline constexpr std::array<int, num_testfiles> test_file_dimension = { 2, 2, 2, 3, 3 };
inline constexpr std::array<int, num_testfiles> test_file_format = { MSH_FILE, MSH_FILE, MSH_FILE, MSH_FILE, VTK_FILE };
inline constexpr std::string_view test_file_path ("test/testfiles/");
inline constexpr std::string_view test_file_refined_ending ("_refined");

class geometry_cad_component: public testing::TestWithParam<int> {
 protected:
  void
  SetUp () override
  {
#if !T8_ENABLE_VTK
    GTEST_SKIP ();
#endif
    /* Load both input meshes. The source and the target mesh. */
    const std::string filepath = std::string (test_file_path) + std::string (test_files[GetParam ()]);
    const std::string filepath_target = filepath + std::string (test_file_refined_ending);
    const int dim = test_file_dimension[GetParam ()];

    const sc_MPI_Comm comm = sc_MPI_COMM_WORLD;
    t8_cmesh_t cmesh = t8_cmesh_from_msh_file (filepath.c_str (), 0, comm, dim, 0, 1);
    forest = t8_forest_new_uniform (cmesh, t8_scheme_new_default (), 1, 0, comm);

    /* Depending on the tested mesh it is either a msh or vtu file. */
    t8_cmesh_t target_cmesh;
    switch (test_file_format[GetParam ()]) {
    case MSH_FILE:
      target_cmesh = t8_cmesh_from_msh_file (filepath_target.c_str (), 0, comm, dim, 0, 0);
      break;
    case VTK_FILE:
#if T8_ENABLE_VTK
    {
      const std::string filepath_w_filetype = filepath_target + ".vtu";
      target_cmesh = t8_vtk_reader_cmesh (filepath_w_filetype.c_str (), 0, 0, comm, VTK_UNSTRUCTURED_FILE,
                                          t8_testsuite_get_package_id (), 0);
    }
#endif
    break;
    default:
      SC_ABORT_NOT_REACHED ();
    }
    target_forest = t8_forest_new_uniform (target_cmesh, t8_scheme_new_default (), 0, 0, comm);
  }

  void
  TearDown () override
  {
    t8_forest_unref (&forest);
    t8_forest_unref (&target_forest);
  }
  t8_forest_t forest;
  t8_forest_t target_forest;
};

/** To identify a cell we use its centroid and its vertices. */
struct cell_search_query
{
  t8_3D_point centroid;
  std::array<t8_3D_point, T8_ECLASS_MAX_CORNERS> vertices;
};

/**
 * The queries are the only thing we search for. So the search should always continue and we
 * return 1.
 * \param [in] forest            The forest.
 * \param [in] ltreeid           The local tree id.
 * \param [in] element           The element.
 * \param [in] is_leaf           true if the element is a leaf.
 * \param [in] leaf_elements     the leaf elements in \a forest that are descendants of \a element (or the element
 *                               itself if \a is_leaf is true)
 * \param[in] tree_leaf_index    the local index of the first leaf in \a leaf_elements
 * \return 1
 */
static int
search_callback ([[maybe_unused]] t8_forest_t forest, [[maybe_unused]] const t8_locidx_t ltreeid,
                 [[maybe_unused]] const t8_element_t *element, [[maybe_unused]] const int is_leaf,
                 [[maybe_unused]] const t8_element_array_t *leaf_elements,
                 [[maybe_unused]] const t8_locidx_t tree_leaf_index)
{
  return 1;
}

/**
 * The query function which does the actual testing. It searches if the same elements are present
 * in both meshes.
 *
 * \param[in] forest              the forest
 * \param[in] ltreeid             the local tree id of the current tree
 * \param[in] element             the element for which the queries are executed
 * \param[in] is_leaf             true if and only if \a element is a leaf element
 * \param[in] leaf_elements       the leaf elements in \a forest that are descendants of \a element (or the element
 *                                itself if \a is_leaf is true)
 * \param[in] tree_leaf_index     the local index of the first leaf in \a leaf_elements
 * \param[in] queries             An array of queries that are checked by the function
 * \param[in] query_indices       An array of size_t entries, where each entry is an index of a query in \a queries.
 * \param[in, out] query_matches  An array of length \a num_active_queries.
 *                                If the element is not a leave must be set to true or false at the i-th index for
 *                                each query, specifying whether the element 'matches' the query of the i-th query
 *                                index or not. When the element is a leaf we can return before all entries are set.
 * \param[in] num_active_queries  The number of currently active queries (equals the number of entries of
 *                                \a query_matches and entries of \a query_indices).
 */
static void
search_query_callback (t8_forest_t forest, const t8_locidx_t ltreeid, const t8_element_t *element, const int is_leaf,
                       [[maybe_unused]] const t8_element_array_t *leaf_elements,
                       [[maybe_unused]] const t8_locidx_t tree_leaf_index, sc_array_t *queries,
                       sc_array_t *query_indices, int *query_matches, const size_t num_active_queries)
{
  /* Build a vector of all centroid-coords, necessary for t8_forest_element_point_batch_inside */
  std::vector<double> coords;
  coords.reserve (3 * num_active_queries);
  for (size_t cell_iter = 0; cell_iter < num_active_queries; cell_iter++) {
    /* Get the query at the current query-index (cell_iter in this case). */
    const size_t cell_id = *(size_t *) sc_array_index_int (query_indices, cell_iter);
    /* Cast the query into a particle*/
    const cell_search_query *cell = (cell_search_query *) sc_array_index (queries, cell_id);
    /* extract the centroid coordinates of the particle struct */
    coords.push_back (cell->centroid[0]);
    coords.push_back (cell->centroid[1]);
    coords.push_back (cell->centroid[2]);
  }
  /* Test whether the particles are inside this element. */
  t8_forest_element_points_inside (forest, ltreeid, element, coords.data (), num_active_queries, query_matches,
                                   T8_PRECISION_SQRT_EPS);

  /* If the element is not a leaf the function ends here. */

  if (is_leaf) {
    /* We expect that there is only one centroid contained in our leaf element. The centroid of the matching element in the target forest.*/
    std::span<int> query_matches_cpp (query_matches, num_active_queries);
    const size_t num_hits = std::accumulate (query_matches_cpp.begin (), query_matches_cpp.end (), 0);
    ASSERT_EQ (num_hits, 1);

    /* Get the matching cell */
    t8_locidx_t matching_cell_id = -1;
    for (size_t i_match = 0; i_match < num_active_queries; ++i_match) {
      if (query_matches[i_match] == 1) {
        matching_cell_id = *(t8_locidx_t *) sc_array_index_int (query_indices, i_match);
        break;
      }
    }
    T8_ASSERT (matching_cell_id != -1);
    const cell_search_query *matching_cell = (cell_search_query *) sc_array_index (queries, matching_cell_id);

    /* Iterate over each corner of the element and check if it is also present in the target forest element. */
    const t8_scheme *scheme = t8_forest_get_scheme (forest);
    const t8_eclass_t eclass = t8_forest_get_eclass (forest, ltreeid);
    const t8_element_shape_t shape = scheme->element_get_shape (eclass, element);
    t8_3D_point vertex;
    for (int corner_number = 0; corner_number < t8_eclass_num_vertices[shape]; ++corner_number) {
      t8_forest_element_coordinate (forest, ltreeid, element, corner_number, vertex.data ());
      bool cell_vertex_found = false;
      for (const auto &cell_vertex : matching_cell->vertices) {
        if (t8_eq (cell_vertex, vertex, 1e-4)) {
          ASSERT_FALSE (cell_vertex_found);
          cell_vertex_found = true;
        }
      }
      ASSERT_TRUE (cell_vertex_found);
    }
  }
}

/** Test whether the target forest and the base forest at level 1 are equal.  */
TEST_P (geometry_cad_component, manually_refined_test)
{
  const t8_scheme *scheme = t8_forest_get_scheme (forest);
  const t8_locidx_t num_trees_target_forest = t8_forest_get_local_num_leaf_elements (target_forest);
  T8_ASSERTF (num_trees_target_forest == t8_forest_get_num_global_trees (target_forest),
              "target_forest is either partitioned or not level 0.");
  T8_ASSERTF (t8_forest_get_local_num_leaf_elements (target_forest) == t8_forest_get_local_num_leaf_elements (forest),
              "forest and target_forest do not have the same number of elements.");

  /* Build the queries with centroid and corner coords from the target forest. */
  std::vector<cell_search_query> cells (num_trees_target_forest);
  for (t8_locidx_t itree = 0; itree < num_trees_target_forest; ++itree) {
    const t8_element_t *elem = t8_forest_get_leaf_element_in_tree (target_forest, itree, 0);
    const t8_eclass_t eclass = t8_forest_get_eclass (target_forest, itree);
    const t8_element_shape_t shape = scheme->element_get_shape (eclass, elem);

    t8_forest_element_centroid (target_forest, itree, elem, cells[itree].centroid.data ());
    for (int corner_number = 0; corner_number < t8_eclass_num_vertices[shape]; ++corner_number) {
      t8_forest_element_coordinate (target_forest, itree, elem, corner_number,
                                    cells[itree].vertices[corner_number].data ());
    }
  }

  /* Call the search */
  sc_array_t *cells_view = sc_array_new_data (cells.data (), sizeof (cell_search_query), cells.size ());
  t8_forest_search (forest, search_callback, search_query_callback, cells_view);
  sc_array_destroy (cells_view);
}

/* Currently does not work for parallel files. Replace with VTK_NUM_TYPES as soon
 * as reading and constructing cmeshes from parallel files is enabled. */
INSTANTIATE_TEST_SUITE_P (t8_gtest_geometry_cad_component, geometry_cad_component, testing::Range (0, num_testfiles));
