<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t8: src/t8_element_c_interface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">t8
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">t8code is a C library to manage a forest of adaptive                           space-trees of general element classes in parallel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">t8_element_c_interface.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines the c interface to (some of) the member functions of the t8_eclass_scheme_c class.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="t8__element_8h_source.html">t8_element.h</a>&gt;</code><br />
</div>
<p><a href="t8__element__c__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a776aaa4172dd34de8c91f4272aac18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a0a776aaa4172dd34de8c91f4272aac18">t8_element_size</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts)</td></tr>
<tr class="memdesc:a0a776aaa4172dd34de8c91f4272aac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of any element of a given class.  <a href="t8__element__c__interface_8h.html#a0a776aaa4172dd34de8c91f4272aac18">More...</a><br /></td></tr>
<tr class="separator:a0a776aaa4172dd34de8c91f4272aac18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e7ebe8a67c864932cd12f4e12a8fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a227e7ebe8a67c864932cd12f4e12a8fa">t8_element_refines_irregular</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts)</td></tr>
<tr class="memdesc:a227e7ebe8a67c864932cd12f4e12a8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if there is one element in the tree, that does not refine into 2^dim children.  <a href="t8__element__c__interface_8h.html#a227e7ebe8a67c864932cd12f4e12a8fa">More...</a><br /></td></tr>
<tr class="separator:a227e7ebe8a67c864932cd12f4e12a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cea50ab42155d93fd340c7883d3dc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a82cea50ab42155d93fd340c7883d3dc3">t8_element_maxlevel</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts)</td></tr>
<tr class="memdesc:a82cea50ab42155d93fd340c7883d3dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowed level for any element of a given class.  <a href="t8__element__c__interface_8h.html#a82cea50ab42155d93fd340c7883d3dc3">More...</a><br /></td></tr>
<tr class="separator:a82cea50ab42155d93fd340c7883d3dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ec88f3c855e455d3ea790e24f088d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a66ec88f3c855e455d3ea790e24f088d9">t8_element_child_eclass</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, int childid)</td></tr>
<tr class="memdesc:a66ec88f3c855e455d3ea790e24f088d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of each child in the ordering of the implementation.  <a href="t8__element__c__interface_8h.html#a66ec88f3c855e455d3ea790e24f088d9">More...</a><br /></td></tr>
<tr class="separator:a66ec88f3c855e455d3ea790e24f088d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70250c69cfc23b346ff47ab4ae5cc1d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a70250c69cfc23b346ff47ab4ae5cc1d9">t8_element_level</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a70250c69cfc23b346ff47ab4ae5cc1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of a particular element.  <a href="t8__element__c__interface_8h.html#a70250c69cfc23b346ff47ab4ae5cc1d9">More...</a><br /></td></tr>
<tr class="separator:a70250c69cfc23b346ff47ab4ae5cc1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6692d42e5fadec3282c35ef86cc5f08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a6692d42e5fadec3282c35ef86cc5f08e">t8_element_copy</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *source, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *dest)</td></tr>
<tr class="memdesc:a6692d42e5fadec3282c35ef86cc5f08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all entries of <b>source</b> to <b>dest</b>.  <a href="t8__element__c__interface_8h.html#a6692d42e5fadec3282c35ef86cc5f08e">More...</a><br /></td></tr>
<tr class="separator:a6692d42e5fadec3282c35ef86cc5f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549d3db50cb3387184638c6347651077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a549d3db50cb3387184638c6347651077">t8_element_compare</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2)</td></tr>
<tr class="memdesc:a549d3db50cb3387184638c6347651077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two elements.  <a href="t8__element__c__interface_8h.html#a549d3db50cb3387184638c6347651077">More...</a><br /></td></tr>
<tr class="separator:a549d3db50cb3387184638c6347651077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3954864171f17e3c5b92e794772487b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a3954864171f17e3c5b92e794772487b9">t8_element_parent</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *parent)</td></tr>
<tr class="memdesc:a3954864171f17e3c5b92e794772487b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the parent of a given element <b>elem</b> and store it in <b>parent</b>.  <a href="t8__element__c__interface_8h.html#a3954864171f17e3c5b92e794772487b9">More...</a><br /></td></tr>
<tr class="separator:a3954864171f17e3c5b92e794772487b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2869863d3c2fc1ebe21bdcc23af032"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a3c2869863d3c2fc1ebe21bdcc23af032">t8_element_num_siblings</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a3c2869863d3c2fc1ebe21bdcc23af032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of siblings of an element.  <a href="t8__element__c__interface_8h.html#a3c2869863d3c2fc1ebe21bdcc23af032">More...</a><br /></td></tr>
<tr class="separator:a3c2869863d3c2fc1ebe21bdcc23af032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfcddeff735c6ad3f930ac3fe4d6514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a4bfcddeff735c6ad3f930ac3fe4d6514">t8_element_sibling</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int sibid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *sibling)</td></tr>
<tr class="memdesc:a4bfcddeff735c6ad3f930ac3fe4d6514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a specific sibling of a given element <b>elem</b> and store it in <b>sibling</b>.  <a href="t8__element__c__interface_8h.html#a4bfcddeff735c6ad3f930ac3fe4d6514">More...</a><br /></td></tr>
<tr class="separator:a4bfcddeff735c6ad3f930ac3fe4d6514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e63d63718392a1dd8f9988419dbb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#ae72e63d63718392a1dd8f9988419dbb2">t8_element_num_corners</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:ae72e63d63718392a1dd8f9988419dbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of corners of an element.  <a href="t8__element__c__interface_8h.html#ae72e63d63718392a1dd8f9988419dbb2">More...</a><br /></td></tr>
<tr class="separator:ae72e63d63718392a1dd8f9988419dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f85bbba6684e2072b9d96afb91cf12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a92f85bbba6684e2072b9d96afb91cf12">t8_element_num_faces</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a92f85bbba6684e2072b9d96afb91cf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of faces of an element.  <a href="t8__element__c__interface_8h.html#a92f85bbba6684e2072b9d96afb91cf12">More...</a><br /></td></tr>
<tr class="separator:a92f85bbba6684e2072b9d96afb91cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721176e7cc438dc72016735aa7afac65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a721176e7cc438dc72016735aa7afac65">t8_element_max_num_faces</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a721176e7cc438dc72016735aa7afac65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of faces of a given element and all of its descendants.  <a href="t8__element__c__interface_8h.html#a721176e7cc438dc72016735aa7afac65">More...</a><br /></td></tr>
<tr class="separator:a721176e7cc438dc72016735aa7afac65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8947eff31bdf92f237051986f684c1a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a8947eff31bdf92f237051986f684c1a3">t8_element_num_children</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a8947eff31bdf92f237051986f684c1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of children of an element when it is refined.  <a href="t8__element__c__interface_8h.html#a8947eff31bdf92f237051986f684c1a3">More...</a><br /></td></tr>
<tr class="separator:a8947eff31bdf92f237051986f684c1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d2d610e54ab8d71d95198ee5528974"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a75d2d610e54ab8d71d95198ee5528974">t8_element_num_face_children</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face)</td></tr>
<tr class="memdesc:a75d2d610e54ab8d71d95198ee5528974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of children of an element's face when the element is refined.  <a href="t8__element__c__interface_8h.html#a75d2d610e54ab8d71d95198ee5528974">More...</a><br /></td></tr>
<tr class="separator:a75d2d610e54ab8d71d95198ee5528974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeb79248862e98cebb52d00d4177cb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#adbeb79248862e98cebb52d00d4177cb4">t8_element_get_face_corner</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, int corner)</td></tr>
<tr class="memdesc:adbeb79248862e98cebb52d00d4177cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corner number of an element's face corner.  <a href="t8__element__c__interface_8h.html#adbeb79248862e98cebb52d00d4177cb4">More...</a><br /></td></tr>
<tr class="separator:adbeb79248862e98cebb52d00d4177cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108ba9d5c3215c5a3bda68d51130afe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a108ba9d5c3215c5a3bda68d51130afe3">t8_element_get_corner_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int corner, int face)</td></tr>
<tr class="memdesc:a108ba9d5c3215c5a3bda68d51130afe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the face numbers of the faces sharing an element's corner.  <a href="t8__element__c__interface_8h.html#a108ba9d5c3215c5a3bda68d51130afe3">More...</a><br /></td></tr>
<tr class="separator:a108ba9d5c3215c5a3bda68d51130afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42cf937af27e8c191cabfc45fcb88c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#ae42cf937af27e8c191cabfc45fcb88c7">t8_element_child</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int childid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *child)</td></tr>
<tr class="memdesc:ae42cf937af27e8c191cabfc45fcb88c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the child element of a given number.  <a href="t8__element__c__interface_8h.html#ae42cf937af27e8c191cabfc45fcb88c7">More...</a><br /></td></tr>
<tr class="separator:ae42cf937af27e8c191cabfc45fcb88c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e74f9da1f7b2153d24a619c7827d2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a5e74f9da1f7b2153d24a619c7827d2d2">t8_element_children</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *c[])</td></tr>
<tr class="memdesc:a5e74f9da1f7b2153d24a619c7827d2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct all children of a given element.  <a href="t8__element__c__interface_8h.html#a5e74f9da1f7b2153d24a619c7827d2d2">More...</a><br /></td></tr>
<tr class="separator:a5e74f9da1f7b2153d24a619c7827d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7308cd7867b67646b3693448e16cfaac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a7308cd7867b67646b3693448e16cfaac">t8_element_child_id</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a7308cd7867b67646b3693448e16cfaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the child id of an element.  <a href="t8__element__c__interface_8h.html#a7308cd7867b67646b3693448e16cfaac">More...</a><br /></td></tr>
<tr class="separator:a7308cd7867b67646b3693448e16cfaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85834aa9a392b69ccd29d8cfec29e859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a85834aa9a392b69ccd29d8cfec29e859">t8_element_ancestor_id</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int level)</td></tr>
<tr class="memdesc:a85834aa9a392b69ccd29d8cfec29e859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ancestor id of an element, that is the child id at a given level.  <a href="t8__element__c__interface_8h.html#a85834aa9a392b69ccd29d8cfec29e859">More...</a><br /></td></tr>
<tr class="separator:a85834aa9a392b69ccd29d8cfec29e859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e2876567a049c380ea08ab6d03f96a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a32e2876567a049c380ea08ab6d03f96a">t8_element_is_family</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **fam)</td></tr>
<tr class="memdesc:a32e2876567a049c380ea08ab6d03f96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given set of elements is a family or not.  <a href="t8__element__c__interface_8h.html#a32e2876567a049c380ea08ab6d03f96a">More...</a><br /></td></tr>
<tr class="separator:a32e2876567a049c380ea08ab6d03f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a2d8e2783cc1ada97e6a8ca8023d1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a31a2d8e2783cc1ada97e6a8ca8023d1a">t8_element_nca</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *nca)</td></tr>
<tr class="memdesc:a31a2d8e2783cc1ada97e6a8ca8023d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nearest common ancestor of two elements.  <a href="t8__element__c__interface_8h.html#a31a2d8e2783cc1ada97e6a8ca8023d1a">More...</a><br /></td></tr>
<tr class="separator:a31a2d8e2783cc1ada97e6a8ca8023d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980b9e4c6403d88d58ee0e28aad9ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#ac980b9e4c6403d88d58ee0e28aad9ae8">t8_element_face_shape</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face)</td></tr>
<tr class="memdesc:ac980b9e4c6403d88d58ee0e28aad9ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shape of the face of an element.  <a href="t8__element__c__interface_8h.html#ac980b9e4c6403d88d58ee0e28aad9ae8">More...</a><br /></td></tr>
<tr class="separator:ac980b9e4c6403d88d58ee0e28aad9ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2836e07940c42bfb45e59aa9f689218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#ad2836e07940c42bfb45e59aa9f689218">t8_element_children_at_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *children[], int num_children, int *child_indices)</td></tr>
<tr class="memdesc:ad2836e07940c42bfb45e59aa9f689218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of the element, compute all children of the element that touch the face.  <a href="t8__element__c__interface_8h.html#ad2836e07940c42bfb45e59aa9f689218">More...</a><br /></td></tr>
<tr class="separator:ad2836e07940c42bfb45e59aa9f689218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc07a71fa0256ec4ed1a080ed22fb8a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#acc07a71fa0256ec4ed1a080ed22fb8a9">t8_element_face_child_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, int face_child)</td></tr>
<tr class="memdesc:acc07a71fa0256ec4ed1a080ed22fb8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face.  <a href="t8__element__c__interface_8h.html#acc07a71fa0256ec4ed1a080ed22fb8a9">More...</a><br /></td></tr>
<tr class="separator:acc07a71fa0256ec4ed1a080ed22fb8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcaceeb9175d1a6a7aa8264a3683a4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#afbcaceeb9175d1a6a7aa8264a3683a4e">t8_element_face_parent_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face)</td></tr>
<tr class="memdesc:afbcaceeb9175d1a6a7aa8264a3683a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element return the face number of the parent of the element that matches the element's face.  <a href="t8__element__c__interface_8h.html#afbcaceeb9175d1a6a7aa8264a3683a4e">More...</a><br /></td></tr>
<tr class="separator:afbcaceeb9175d1a6a7aa8264a3683a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8310ca682d77de078cb159de210f40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#aef8310ca682d77de078cb159de210f40">t8_element_tree_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face)</td></tr>
<tr class="memdesc:aef8310ca682d77de078cb159de210f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of this element.  <a href="t8__element__c__interface_8h.html#aef8310ca682d77de078cb159de210f40">More...</a><br /></td></tr>
<tr class="separator:aef8310ca682d77de078cb159de210f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8804c5c45bdebfe60c63bc88a2897f65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a8804c5c45bdebfe60c63bc88a2897f65">t8_element_transform_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, int orientation, int sign, int is_smaller_face)</td></tr>
<tr class="memdesc:a8804c5c45bdebfe60c63bc88a2897f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we have two trees that share a common face f.  <a href="t8__element__c__interface_8h.html#a8804c5c45bdebfe60c63bc88a2897f65">More...</a><br /></td></tr>
<tr class="separator:a8804c5c45bdebfe60c63bc88a2897f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4e113dcc94951c6325c710584d3da2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a4b4e113dcc94951c6325c710584d3da2">t8_element_extrude_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *face, const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *face_scheme, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int root_face)</td></tr>
<tr class="memdesc:a4b4e113dcc94951c6325c710584d3da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face.  <a href="t8__element__c__interface_8h.html#a4b4e113dcc94951c6325c710584d3da2">More...</a><br /></td></tr>
<tr class="separator:a4b4e113dcc94951c6325c710584d3da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c5857b58402b4768ba6170a431232d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a86c5857b58402b4768ba6170a431232d">t8_element_boundary_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *boundary, const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *boundary_scheme)</td></tr>
<tr class="memdesc:a86c5857b58402b4768ba6170a431232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the boundary element at a specific face.  <a href="t8__element__c__interface_8h.html#a86c5857b58402b4768ba6170a431232d">More...</a><br /></td></tr>
<tr class="separator:a86c5857b58402b4768ba6170a431232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc94ecc4c6b6053edfbf97521e1c2a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#acfc94ecc4c6b6053edfbf97521e1c2a2">t8_element_first_descendant_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *first_desc, int level)</td></tr>
<tr class="memdesc:acfc94ecc4c6b6053edfbf97521e1c2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the first descendant of an element at a given level that touches a given face.  <a href="t8__element__c__interface_8h.html#acfc94ecc4c6b6053edfbf97521e1c2a2">More...</a><br /></td></tr>
<tr class="separator:acfc94ecc4c6b6053edfbf97521e1c2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade69ead3b782fcb76634e4d67d9c0c29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#ade69ead3b782fcb76634e4d67d9c0c29">t8_element_last_descendant_face</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *last_desc, int level)</td></tr>
<tr class="memdesc:ade69ead3b782fcb76634e4d67d9c0c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the last descendant of an element at a given level that touches a given face.  <a href="t8__element__c__interface_8h.html#ade69ead3b782fcb76634e4d67d9c0c29">More...</a><br /></td></tr>
<tr class="separator:ade69ead3b782fcb76634e4d67d9c0c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6ad9828448761eecf57d4e09d68e00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a9e6ad9828448761eecf57d4e09d68e00">t8_element_is_root_boundary</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face)</td></tr>
<tr class="memdesc:a9e6ad9828448761eecf57d4e09d68e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct all codimension-one boundary elements of a given element.  <a href="t8__element__c__interface_8h.html#a9e6ad9828448761eecf57d4e09d68e00">More...</a><br /></td></tr>
<tr class="separator:a9e6ad9828448761eecf57d4e09d68e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc1689396a75db1e6890cecdba93bca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a6cc1689396a75db1e6890cecdba93bca">t8_element_face_neighbor_inside</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *neigh, int face, int *neigh_face)</td></tr>
<tr class="memdesc:a6cc1689396a75db1e6890cecdba93bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the face neighbor of a given element if this face neighbor is inside the root tree.  <a href="t8__element__c__interface_8h.html#a6cc1689396a75db1e6890cecdba93bca">More...</a><br /></td></tr>
<tr class="separator:a6cc1689396a75db1e6890cecdba93bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cce2680729c61d2c3569a7d2d0830e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a51cce2680729c61d2c3569a7d2d0830e">t8_element_shape</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a51cce2680729c61d2c3569a7d2d0830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape of an allocated element according its type.  <a href="t8__element__c__interface_8h.html#a51cce2680729c61d2c3569a7d2d0830e">More...</a><br /></td></tr>
<tr class="separator:a51cce2680729c61d2c3569a7d2d0830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa65b8cf5be7c79a32df339de11905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a75aa65b8cf5be7c79a32df339de11905">t8_element_set_linear_id</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int level, <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> id)</td></tr>
<tr class="memdesc:a75aa65b8cf5be7c79a32df339de11905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the entries of an allocated element according to a given linear id in a uniform refinement.  <a href="t8__element__c__interface_8h.html#a75aa65b8cf5be7c79a32df339de11905">More...</a><br /></td></tr>
<tr class="separator:a75aa65b8cf5be7c79a32df339de11905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef3d0c31a3cdf90fb6aadb75f0e9a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a2ef3d0c31a3cdf90fb6aadb75f0e9a3b">t8_element_get_linear_id</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int level)</td></tr>
<tr class="memdesc:a2ef3d0c31a3cdf90fb6aadb75f0e9a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear id of a given element in a hypothetical uniform refinement of a given level.  <a href="t8__element__c__interface_8h.html#a2ef3d0c31a3cdf90fb6aadb75f0e9a3b">More...</a><br /></td></tr>
<tr class="separator:a2ef3d0c31a3cdf90fb6aadb75f0e9a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e26dab796cfcb4790868e6d4012238d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a9e26dab796cfcb4790868e6d4012238d">t8_element_first_descendant</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, int level)</td></tr>
<tr class="memdesc:a9e26dab796cfcb4790868e6d4012238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first descendant of a given element.  <a href="t8__element__c__interface_8h.html#a9e26dab796cfcb4790868e6d4012238d">More...</a><br /></td></tr>
<tr class="separator:a9e26dab796cfcb4790868e6d4012238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716501b713d90046fbc4b84da820897c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a716501b713d90046fbc4b84da820897c">t8_element_last_descendant</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, int level)</td></tr>
<tr class="memdesc:a716501b713d90046fbc4b84da820897c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the last descendant of a given element.  <a href="t8__element__c__interface_8h.html#a716501b713d90046fbc4b84da820897c">More...</a><br /></td></tr>
<tr class="separator:a716501b713d90046fbc4b84da820897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74607f90e9f33ac36aa2e3a510886daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a74607f90e9f33ac36aa2e3a510886daf">t8_element_successor</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, int level)</td></tr>
<tr class="memdesc:a74607f90e9f33ac36aa2e3a510886daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the successor in a uniform refinement of a given element.  <a href="t8__element__c__interface_8h.html#a74607f90e9f33ac36aa2e3a510886daf">More...</a><br /></td></tr>
<tr class="separator:a74607f90e9f33ac36aa2e3a510886daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8040836ec3124cf994ba873debbc1f43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a8040836ec3124cf994ba873debbc1f43">t8_element_root_len</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem)</td></tr>
<tr class="memdesc:a8040836ec3124cf994ba873debbc1f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the root lenght of a given element, that is the length of its level 0 ancestor.  <a href="t8__element__c__interface_8h.html#a8040836ec3124cf994ba873debbc1f43">More...</a><br /></td></tr>
<tr class="separator:a8040836ec3124cf994ba873debbc1f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ead72c4dcec625a6132995f545a9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a49ead72c4dcec625a6132995f545a9a1">t8_element_vertex_reference_coords</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *t, const int vertex, double coords[])</td></tr>
<tr class="memdesc:a49ead72c4dcec625a6132995f545a9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension).  <a href="t8__element__c__interface_8h.html#a49ead72c4dcec625a6132995f545a9a1">More...</a><br /></td></tr>
<tr class="separator:a49ead72c4dcec625a6132995f545a9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768f979bf3a2b707adf51abd6e381f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a768f979bf3a2b707adf51abd6e381f3f">t8_element_count_leafs</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *t, int level)</td></tr>
<tr class="memdesc:a768f979bf3a2b707adf51abd6e381f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a t8_element in an array indexed by a size_t.  <a href="t8__element__c__interface_8h.html#a768f979bf3a2b707adf51abd6e381f3f">More...</a><br /></td></tr>
<tr class="separator:a768f979bf3a2b707adf51abd6e381f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5536fe2c65dbdac05d6f5fc0e45ee841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a5536fe2c65dbdac05d6f5fc0e45ee841">t8_element_count_leafs_from_root</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, int level)</td></tr>
<tr class="memdesc:a5536fe2c65dbdac05d6f5fc0e45ee841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level the root element will produce.  <a href="t8__element__c__interface_8h.html#a5536fe2c65dbdac05d6f5fc0e45ee841">More...</a><br /></td></tr>
<tr class="separator:a5536fe2c65dbdac05d6f5fc0e45ee841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e468b415f696b3f13a642fce87ad1b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a9e468b415f696b3f13a642fce87ad1b3">t8_element_general_function</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const void *indata, void *outdata)</td></tr>
<tr class="memdesc:a9e468b415f696b3f13a642fce87ad1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has no defined effect but each implementation is free to provide its own meaning of it.  <a href="t8__element__c__interface_8h.html#a9e468b415f696b3f13a642fce87ad1b3">More...</a><br /></td></tr>
<tr class="separator:a9e468b415f696b3f13a642fce87ad1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d75e09b14098e69b7b7ba48de4d1d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#a0d75e09b14098e69b7b7ba48de4d1d8f">t8_element_new</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elems)</td></tr>
<tr class="memdesc:a0d75e09b14098e69b7b7ba48de4d1d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for an array of elements of a given class and initialize them.  <a href="t8__element__c__interface_8h.html#a0d75e09b14098e69b7b7ba48de4d1d8f">More...</a><br /></td></tr>
<tr class="separator:a0d75e09b14098e69b7b7ba48de4d1d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a07f9354179702f3b6aa0155f71573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t8__element__c__interface_8h.html#af4a07f9354179702f3b6aa0155f71573">t8_element_destroy</a> (const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *ts, int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elems)</td></tr>
<tr class="memdesc:af4a07f9354179702f3b6aa0155f71573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate an array of elements.  <a href="t8__element__c__interface_8h.html#af4a07f9354179702f3b6aa0155f71573">More...</a><br /></td></tr>
<tr class="separator:af4a07f9354179702f3b6aa0155f71573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the c interface to (some of) the member functions of the t8_eclass_scheme_c class. </p>
<p>We recomment to use the C++ functions directly and only use this interface when you really need to use C. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a85834aa9a392b69ccd29d8cfec29e859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85834aa9a392b69ccd29d8cfec29e859">&#9670;&nbsp;</a></span>t8_element_ancestor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_ancestor_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the ancestor id of an element, that is the child id at a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. Must satisfy <em>level</em> &lt; elem.level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child_id of <em>elem</em> in regard to its <em>level</em> ancestor. </dd></dl>

</div>
</div>
<a id="a86c5857b58402b4768ba6170a431232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c5857b58402b4768ba6170a431232d">&#9670;&nbsp;</a></span>t8_element_boundary_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_boundary_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>boundary_scheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the boundary element at a specific face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face of which to construct the boundary element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundary</td><td>An allocated element of dimension of <em>element</em> minus 1. The entries will be filled with the entries of the face of <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_scheme</td><td>The scheme for the eclass of the boundary face. If <em>elem</em> is of class T8_ECLASS_VERTEX, then <em>boundary</em> must be NULL and will not be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae42cf937af27e8c191cabfc45fcb88c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42cf937af27e8c191cabfc45fcb88c7">&#9670;&nbsp;</a></span>t8_element_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>childid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the child element of a given number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childid</td><td>The number of the child to construct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child</td><td>The storage for this element must exist and match the element class of the child. For a pyramid, for example, it may be either a tetrahedron or a pyramid depending on <em>childid</em>. This can be checked by <em>t8_element_child_eclass</em>. On output, a valid element. It is valid to call this function with elem = child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__element__c__interface_8h.html#a66ec88f3c855e455d3ea790e24f088d9" title="Return the type of each child in the ordering of the implementation.">t8_element_child_eclass</a> </dd></dl>

</div>
</div>
<a id="a66ec88f3c855e455d3ea790e24f088d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ec88f3c855e455d3ea790e24f088d9">&#9670;&nbsp;</a></span>t8_element_child_eclass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> t8_element_child_eclass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>childid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of each child in the ordering of the implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childid</td><td>Must be between 0 and the number of children (exclusive). The number of children is defined in <em>t8_element_num_children</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type for the given child. </dd></dl>

</div>
</div>
<a id="a7308cd7867b67646b3693448e16cfaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7308cd7867b67646b3693448e16cfaac">&#9670;&nbsp;</a></span>t8_element_child_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_child_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the child id of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id of elem. </dd></dl>

</div>
</div>
<a id="a5e74f9da1f7b2153d24a619c7827d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e74f9da1f7b2153d24a619c7827d2d2">&#9670;&nbsp;</a></span>t8_element_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct all children of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the output array <em>c</em> must match the number of children. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The storage for these <em>length</em> elements must exist and match the element class in the children's ordering. On output, all children are valid. It is valid to call this function with elem = c[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__element__c__interface_8h.html#a8947eff31bdf92f237051986f684c1a3" title="Compute the number of children of an element when it is refined.">t8_element_num_children</a> </dd>
<dd>
<a class="el" href="t8__element__c__interface_8h.html#a66ec88f3c855e455d3ea790e24f088d9" title="Return the type of each child in the ordering of the implementation.">t8_element_child_eclass</a> </dd></dl>

</div>
</div>
<a id="ad2836e07940c42bfb45e59aa9f689218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2836e07940c42bfb45e59aa9f689218">&#9670;&nbsp;</a></span>t8_element_children_at_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_children_at_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>child_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an element and a face of the element, compute all children of the element that touch the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">children</td><td>Allocated elements, in which the children of <em>elem</em> that share a face with <em>face</em> are stored. They will be stored in order of their linear id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_children</td><td>The number of elements in <em>children</em>. Must match the number of children that touch <em>face</em>. <a class="el" href="t8__element__c__interface_8h.html#a75d2d610e54ab8d71d95198ee5528974">t8_element_num_face_children</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child_indices</td><td>If not NULL, an array of num_children integers must be given, on output its i-th entry is the child_id of the i-th face_child. It is valid to call this function with elem = children[0]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a549d3db50cb3387184638c6347651077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549d3db50cb3387184638c6347651077">&#9670;&nbsp;</a></span>t8_element_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negativ if elem1 &lt; elem2, zero if elem1 equals elem2 and positiv if elem1 &gt; elem2. If elem2 is a copy of elem1 then the elements are equal. </dd></dl>

</div>
</div>
<a id="a6692d42e5fadec3282c35ef86cc5f08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6692d42e5fadec3282c35ef86cc5f08e">&#9670;&nbsp;</a></span>t8_element_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy all entries of <b>source</b> to <b>dest</b>. </p>
<p><b>dest</b> must be an existing element. No memory is allocated by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The element whose entries will be copied to <b>dest</b>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>This element's entries will be overwritted with the entries of <b>source</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>source</em> and <em>dest</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a768f979bf3a2b707adf51abd6e381f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768f979bf3a2b707adf51abd6e381f3f">&#9670;&nbsp;</a></span>t8_element_count_leafs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> t8_element_count_leafs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a t8_element in an array indexed by a size_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The sc_array storing \t t8_element_t pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>The index of the element that should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the it-th element in <b>array</b>. We provide a default implementation of this routine that should suffice for most use cases. Count how many leaf descendants of a given uniform level an element would produce. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The element to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Suppose <em>t</em> is uniformly refined up to level <em>level</em>. The return value is the resulting number of elements (of the given level). If <em>level</em> &lt; t8_element_level(t), the return value should be 0.</dd></dl>
<p>Example: If <em>t</em> is a line element that refines into 2 line elements on each level, then the return value is max(0, 2^{<em>level</em> - level(<em>t</em>)}). Thus, if <em>t's</em> level is 0, and <em>level</em> = 3, the return value is 2^3 = 8. </p>

</div>
</div>
<a id="a5536fe2c65dbdac05d6f5fc0e45ee841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5536fe2c65dbdac05d6f5fc0e45ee841">&#9670;&nbsp;</a></span>t8_element_count_leafs_from_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> t8_element_count_leafs_from_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level the root element will produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="t8__element__c__interface_8h.html#a768f979bf3a2b707adf51abd6e381f3f">t8_element_count_leafs</a> if the input element is the root (level 0) element.</dd></dl>
<p>This is a convenience function, and can be implemented via <a class="el" href="t8__element__c__interface_8h.html#a768f979bf3a2b707adf51abd6e381f3f">t8_element_count_leafs</a>. </p>

</div>
</div>
<a id="af4a07f9354179702f3b6aa0155f71573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a07f9354179702f3b6aa0155f71573">&#9670;&nbsp;</a></span>t8_element_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate an array of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <b>length</b> many allocated element pointers. On output all these pointers will be freed. <b>elem</b> itself will not be freed by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b4e113dcc94951c6325c710584d3da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4e113dcc94951c6325c710584d3da2">&#9670;&nbsp;</a></span>t8_element_extrude_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_extrude_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>face_scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_scheme</td><td>The scheme for the face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>An allocated element. The entries will be filled with the data of the element that has <em>face</em> as a face and lies within the root tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_face</td><td>The index of the face of the root tree in which <em>face</em> lies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of <em>elem</em> that coincides with <em>face</em>. </dd></dl>

</div>
</div>
<a id="acc07a71fa0256ec4ed1a080ed22fb8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc07a71fa0256ec4ed1a080ed22fb8a9">&#9670;&nbsp;</a></span>t8_element_face_child_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_face_child_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face. </p>
<pre class="fragment">*  x ---- x   x      x           x ---- x
*  |      |   |      |           |   |  | &lt;-- f
*  |      |   |      x           |   x--x
*  |      |   |                  |      |
*  x ---- x   x                  x ---- x
*   elem    face  face_child    Returns the face number f
* </pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_child</td><td>A number 0 &lt;= <em>face_child</em> &lt; num_face_children, specifying a child of <em>elem</em> that shares a face with <em>face</em>. These children are counted in linear order. This coincides with the order of children from a call to <a class="el" href="t8__element__c__interface_8h.html#ad2836e07940c42bfb45e59aa9f689218">t8_element_children_at_face</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of a child of <em>elem</em> that conincides with <em>face_child</em>. </dd></dl>

</div>
</div>
<a id="a6cc1689396a75db1e6890cecdba93bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc1689396a75db1e6890cecdba93bca">&#9670;&nbsp;</a></span>t8_element_face_neighbor_inside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_face_neighbor_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>neigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neigh_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the face neighbor of a given element if this face neighbor is inside the root tree. </p>
<p>Return 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh</td><td>If the face neighbor of <em>elem</em> along <em>face</em> is inside the root tree, this element's data is filled with the data of the face neighbor. Otherwise the data can be modified arbitrarily. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The number of the face along which the neighbor should be constructed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_face</td><td>The number of <em>face</em> as viewed from <em>neigh</em>. An arbitrary value, if the neighbor is not inside the root tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>neigh</em> is inside the root tree. False if not. In this case <em>neigh's</em> data can be arbitrary on output. </dd></dl>

</div>
</div>
<a id="afbcaceeb9175d1a6a7aa8264a3683a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcaceeb9175d1a6a7aa8264a3683a4e">&#9670;&nbsp;</a></span>t8_element_face_parent_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_face_parent_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a face of an element return the face number of the parent of the element that matches the element's face. </p>
<p>Or return -1 if no face of the parent matches the face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>face</em> of <em>elem</em> is also a face of <em>elem's</em> parent, the face number of this face. Otherwise -1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For the root element this function always returns <em>face</em>. </dd></dl>

</div>
</div>
<a id="ac980b9e4c6403d88d58ee0e28aad9ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac980b9e4c6403d88d58ee0e28aad9ae8">&#9670;&nbsp;</a></span>t8_element_face_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_element_face_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the shape of the face of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element shape of the face. I.e. T8_ECLASS_LINE for quads, T8_ECLASS_TRIANGLE for tets and depending on the face number either T8_ECLASS_QUAD or T8_ECLASS_TRIANGLE for prisms. </dd></dl>

</div>
</div>
<a id="a9e26dab796cfcb4790868e6d4012238d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e26dab796cfcb4790868e6d4012238d">&#9670;&nbsp;</a></span>t8_element_first_descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_first_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the first descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The first element in a uniform refinement of <em>elem</em> of the maximum possible level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfc94ecc4c6b6053edfbf97521e1c2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc94ecc4c6b6053edfbf97521e1c2a2">&#9670;&nbsp;</a></span>t8_element_first_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_first_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>first_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the first descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first_desc</td><td>An allocated element. This element's data will be filled with the data of the first descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the first descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e468b415f696b3f13a642fce87ad1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e468b415f696b3f13a642fce87ad1b3">&#9670;&nbsp;</a></span>t8_element_general_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_general_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has no defined effect but each implementation is free to provide its own meaning of it. </p>
<p>Thus this function can be used to compute or lookup very scheme implementation specific data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>An valid element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indata</td><td>Pointer to input data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outdata</td><td>Pointer to output data. For the correct usage of <em>indata</em> and <em>outdata</em> see the specific implementations of the scheme. For example the default scheme triangle and tetrahedron implementations use this function to return the type of a tri/tet to the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a108ba9d5c3215c5a3bda68d51130afe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108ba9d5c3215c5a3bda68d51130afe3">&#9670;&nbsp;</a></span>t8_element_get_corner_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_get_corner_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the face numbers of the faces sharing an element's corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 face 2 Thus for corner = 1 the output is: face=0 : 2, face=1: 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>corner</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the <em>face-th</em> face at <em>corner</em>. </dd></dl>

</div>
</div>
<a id="adbeb79248862e98cebb52d00d4177cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbeb79248862e98cebb52d00d4177cb4">&#9670;&nbsp;</a></span>t8_element_get_face_corner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_get_face_corner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corner number of an element's face corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 Thus for face = 1 the output is: corner=0 : 1, corner=1: 3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face 0 &lt;= <em>corner</em> &lt; num_face_corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner number of the <em>corner-th</em> vertex of <em>face</em>.</dd></dl>
<p>The order in which the corners must be given is determined by the eclass of <em>element:</em> LINE/QUAD/TRIANGLE: No specific order. HEX : In Z-order of the face starting with the lowest corner number. TET : Starting with the lowest corner number counterclockwise as seen from 'outside' of the element. </p>

</div>
</div>
<a id="a2ef3d0c31a3cdf90fb6aadb75f0e9a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef3d0c31a3cdf90fb6aadb75f0e9a3b">&#9670;&nbsp;</a></span>t8_element_get_linear_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> t8_element_get_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the linear id of a given element in a hypothetical uniform refinement of a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose id we compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the element. </dd></dl>

</div>
</div>
<a id="a32e2876567a049c380ea08ab6d03f96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e2876567a049c380ea08ab6d03f96a">&#9670;&nbsp;</a></span>t8_element_is_family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_is_family </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>fam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a given set of elements is a family or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fam</td><td>An array of as many elements as an element of class <b>ts</b> has children. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if <b>fam</b> is not a family, nonzero if it is. </dd></dl>

</div>
</div>
<a id="a9e6ad9828448761eecf57d4e09d68e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6ad9828448761eecf57d4e09d68e00">&#9670;&nbsp;</a></span>t8_element_is_root_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_is_root_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct all codimension-one boundary elements of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>face</em> is a subface of the element's root element. Compute whether a given element shares a given face with its root tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>face</em> is a subface of the element's root element. </dd></dl>

</div>
</div>
<a id="a716501b713d90046fbc4b84da820897c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716501b713d90046fbc4b84da820897c">&#9670;&nbsp;</a></span>t8_element_last_descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_last_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the last descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The last element in a uniform refinement of <em>elem</em> of the maximum possible level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade69ead3b782fcb76634e4d67d9c0c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade69ead3b782fcb76634e4d67d9c0c29">&#9670;&nbsp;</a></span>t8_element_last_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_last_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>last_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the last descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_desc</td><td>An allocated element. This element's data will be filled with the data of the last descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the last descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70250c69cfc23b346ff47ab4ae5cc1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70250c69cfc23b346ff47ab4ae5cc1d9">&#9670;&nbsp;</a></span>t8_element_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the level of a particular element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose level should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of <b>elem</b>. </dd></dl>

</div>
</div>
<a id="a721176e7cc438dc72016735aa7afac65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721176e7cc438dc72016735aa7afac65">&#9670;&nbsp;</a></span>t8_element_max_num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_max_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum number of faces of a given element and all of its descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a82cea50ab42155d93fd340c7883d3dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cea50ab42155d93fd340c7883d3dc3">&#9670;&nbsp;</a></span>t8_element_maxlevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_maxlevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum allowed level for any element of a given class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed level for elements of class <b>ts</b>. </dd></dl>

</div>
</div>
<a id="a31a2d8e2783cc1ada97e6a8ca8023d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a2d8e2783cc1ada97e6a8ca8023d1a">&#9670;&nbsp;</a></span>t8_element_nca()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_nca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>nca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nearest common ancestor of two elements. </p>
<p>That is, the element with highest level that still has both given elements as descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first of the two input elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second of the two input elements. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nca</td><td>The storage for this element must exist and match the element class of the child. On output the unique nearest common ancestor of <b>elem1</b> and <b>elem2</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d75e09b14098e69b7b7ba48de4d1d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d75e09b14098e69b7b7ba48de4d1d8f">&#9670;&nbsp;</a></span>t8_element_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for an array of elements of a given class and initialize them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <b>length</b> many unallocated element pointers. On output all these pointers will point to an allocated and initialized element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not every element that is created in t8code will be created by a call to this function. However, if an element is not created using <a class="el" href="t8__element__c__interface_8h.html#a0d75e09b14098e69b7b7ba48de4d1d8f">t8_element_new</a>, then it is guaranteed that t8_element_init is called on it. </dd>
<dd>
In debugging mode, an element that was created with <a class="el" href="t8__element__c__interface_8h.html#a0d75e09b14098e69b7b7ba48de4d1d8f">t8_element_new</a> must pass t8_element_is_valid. </dd>
<dd>
If an element was created by <a class="el" href="t8__element__c__interface_8h.html#a0d75e09b14098e69b7b7ba48de4d1d8f">t8_element_new</a> then t8_element_init may not be called for it. Thus, <a class="el" href="t8__element__c__interface_8h.html#a0d75e09b14098e69b7b7ba48de4d1d8f">t8_element_new</a> should initialize an element in the same way as a call to t8_element_init would. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>t8_element_init </dd>
<dd>
t8_element_is_valid </dd></dl>

</div>
</div>
<a id="a8947eff31bdf92f237051986f684c1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8947eff31bdf92f237051986f684c1a3">&#9670;&nbsp;</a></span>t8_element_num_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_num_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of children of an element when it is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>element</em>. </dd></dl>

</div>
</div>
<a id="ae72e63d63718392a1dd8f9988419dbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e63d63718392a1dd8f9988419dbb2">&#9670;&nbsp;</a></span>t8_element_num_corners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_num_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of corners of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of corners of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a75d2d610e54ab8d71d95198ee5528974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d2d610e54ab8d71d95198ee5528974">&#9670;&nbsp;</a></span>t8_element_num_face_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_num_face_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of children of an element's face when the element is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>face</em> if <em>elem</em> is to be refined. </dd></dl>

</div>
</div>
<a id="a92f85bbba6684e2072b9d96afb91cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f85bbba6684e2072b9d96afb91cf12">&#9670;&nbsp;</a></span>t8_element_num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of faces of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a3c2869863d3c2fc1ebe21bdcc23af032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2869863d3c2fc1ebe21bdcc23af032">&#9670;&nbsp;</a></span>t8_element_num_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_num_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of siblings of an element. </p>
<p>That is the number of Children of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of siblings of <em>element</em>. Note that this number is &gt;= 1, since we count the element itself as a sibling. </dd></dl>

</div>
</div>
<a id="a3954864171f17e3c5b92e794772487b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3954864171f17e3c5b92e794772487b9">&#9670;&nbsp;</a></span>t8_element_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the parent of a given element <b>elem</b> and store it in <b>parent</b>. </p>
<p><b>parent</b> needs to be an existing element. No memory is allocated by this function. <b>elem</b> and <b>parent</b> can point to the same element, then the entries of <b>elem</b> are overwritten by the ones of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose parent will be computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parent</td><td>This element's entries will be overwritten by those of <b>elem's</b> parent. The storage for this element must exist and match the element class of the parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a227e7ebe8a67c864932cd12f4e12a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e7ebe8a67c864932cd12f4e12a8fa">&#9670;&nbsp;</a></span>t8_element_refines_irregular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_refines_irregular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if there is one element in the tree, that does not refine into 2^dim children. </p>
<p>Returns false otherwise. </p>

</div>
</div>
<a id="a8040836ec3124cf994ba873debbc1f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8040836ec3124cf994ba873debbc1f43">&#9670;&nbsp;</a></span>t8_element_root_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_root_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the root lenght of a given element, that is the length of its level 0 ancestor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose root length should be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The root length of <em>elem</em> </dd></dl>

</div>
</div>
<a id="a75aa65b8cf5be7c79a32df339de11905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa65b8cf5be7c79a32df339de11905">&#9670;&nbsp;</a></span>t8_element_set_linear_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_set_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the entries of an allocated element according to a given linear id in a uniform refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element whose entries will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The linear id. id must fulfil 0 &lt;= id &lt; 'number of leafs in the uniform refinement' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51cce2680729c61d2c3569a7d2d0830e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cce2680729c61d2c3569a7d2d0830e">&#9670;&nbsp;</a></span>t8_element_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_element_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the shape of an allocated element according its type. </p>
<p>For example, a child of an element can be an element of a different shape and has to be handled differently - according to its shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the element as an eclass </dd></dl>

</div>
</div>
<a id="a4bfcddeff735c6ad3f930ac3fe4d6514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfcddeff735c6ad3f930ac3fe4d6514">&#9670;&nbsp;</a></span>t8_element_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sibid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>sibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a specific sibling of a given element <b>elem</b> and store it in <b>sibling</b>. </p>
<p><b>sibling</b> needs to be an existing element. No memory is allocated by this function. <b>elem</b> and <b>sibling</b> can point to the same element, then the entries of <b>elem</b> are overwritten by the ones of its i-th sibling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose sibling will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sibid</td><td>The id of the sibling computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sibling</td><td>This element's entries will be overwritten by those of <b>elem's</b> sibid-th sibling. The storage for this element must exist and match the element class of the sibling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a776aaa4172dd34de8c91f4272aac18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a776aaa4172dd34de8c91f4272aac18">&#9670;&nbsp;</a></span>t8_element_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t t8_element_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of any element of a given class. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of an element of class <b>ts</b>. We provide a default implementation of this routine that should suffice for most use cases. </dd></dl>

</div>
</div>
<a id="a74607f90e9f33ac36aa2e3a510886daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74607f90e9f33ac36aa2e3a510886daf">&#9670;&nbsp;</a></span>t8_element_successor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_successor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the successor in a uniform refinement of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The element whose successor should be constructed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>The element whose entries will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8804c5c45bdebfe60c63bc88a2897f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8804c5c45bdebfe60c63bc88a2897f65">&#9670;&nbsp;</a></span>t8_element_transform_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_transform_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suppose we have two trees that share a common face f. </p>
<p>Given an element e that is a subface of f in one of the trees and given the orientation of the tree connection, construct the face element of the respective tree neighbor that logically coincides with e but lies in the coordinate system of the neighbor tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face elment <em>elem1</em> with respective to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientattion). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="aef8310ca682d77de078cb159de210f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8310ca682d77de078cb159de210f40">&#9670;&nbsp;</a></span>t8_element_tree_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_element_tree_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an element and a face of this element. </p>
<p>If the face lies on the tree boundary, return the face number of the tree face. If not the return value is arbitrary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of a face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the tree face that <em>face</em> is a subface of, if <em>face</em> is on a tree boundary. Any arbitrary integer if <em>is</em> not at a tree boundary. </dd></dl>

</div>
</div>
<a id="a49ead72c4dcec625a6132995f545a9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ead72c4dcec625a6132995f545a9a1">&#9670;&nbsp;</a></span>t8_element_vertex_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_element_vertex_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#a8e03f65f2a4bb4e98dcbe87685a16db9">t8_eclass_scheme_c</a> *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>Implementation of a class scheme. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The id of the vertex whose coordinates shall be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>An array of at least as many doubles as the element's dimension whose entries will be filled with the coordinates of <em>vertex</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
