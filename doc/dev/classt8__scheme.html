<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t8: t8_scheme Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">t8
   &#160;<span id="projectnumber">4.0.0-RC2.318-b667f</span>
   </div>
   <div id="projectbrief">t8code is a C library to manage a forest of adaptive                           space-trees of general element classes in parallel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">t8_scheme Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class holds one or more element schemes.  
 <a href="classt8__scheme.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="t8__scheme_8hxx_source.html">t8_scheme.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed7b30dc711a18f17e455b073c384823"><td class="memItemLeft" align="right" valign="top"><a id="aed7b30dc711a18f17e455b073c384823"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aed7b30dc711a18f17e455b073c384823">scheme_var</a> = std::variant&lt; <a class="el" href="classt8__default__scheme__vertex.html">t8_default_scheme_vertex</a>, <a class="el" href="classt8__default__scheme__line.html">t8_default_scheme_line</a>, <a class="el" href="classt8__default__scheme__quad.html">t8_default_scheme_quad</a>, <a class="el" href="classt8__default__scheme__tri.html">t8_default_scheme_tri</a>, <a class="el" href="classt8__default__scheme__hex.html">t8_default_scheme_hex</a>, <a class="el" href="classt8__default__scheme__tet.html">t8_default_scheme_tet</a>, <a class="el" href="classt8__default__scheme__prism.html">t8_default_scheme_prism</a>, <a class="el" href="classt8__default__scheme__pyramid.html">t8_default_scheme_pyramid</a>, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9ac4ce741ff4e19d3e94aa1eb0c0e7abbd">T8_ECLASS_VERTEX</a> &gt;, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a9667a79817957d7f2446d73a9778b8b5">T8_ECLASS_LINE</a> &gt;, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a81e3f71a30727a94fc1c80da130297a9">T8_ECLASS_QUAD</a> &gt;, <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a5780818d0b9120d3267db871196f866a">T8_ECLASS_HEX</a> &gt; &gt;</td></tr>
<tr class="memdesc:aed7b30dc711a18f17e455b073c384823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant to hold an eclass scheme. <br /></td></tr>
<tr class="separator:aed7b30dc711a18f17e455b073c384823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253d5c003fcee13597b774d3b02cbca3"><td class="memItemLeft" align="right" valign="top"><a id="a253d5c003fcee13597b774d3b02cbca3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a253d5c003fcee13597b774d3b02cbca3">scheme_container</a> = std::vector&lt; <a class="el" href="classt8__scheme.html#aed7b30dc711a18f17e455b073c384823">scheme_var</a> &gt;</td></tr>
<tr class="memdesc:a253d5c003fcee13597b774d3b02cbca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for holding eclass schemes. <br /></td></tr>
<tr class="separator:a253d5c003fcee13597b774d3b02cbca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70cd77d30b141078ac231d5c4a9515b9"><td class="memItemLeft" align="right" valign="top"><a id="a70cd77d30b141078ac231d5c4a9515b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a70cd77d30b141078ac231d5c4a9515b9">ref</a> () const</td></tr>
<tr class="memdesc:a70cd77d30b141078ac231d5c4a9515b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference count of the scheme. <br /></td></tr>
<tr class="separator:a70cd77d30b141078ac231d5c4a9515b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3a78bc332b7868397b835c8317ac47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a4d3a78bc332b7868397b835c8317ac47">unref</a> () const</td></tr>
<tr class="memdesc:a4d3a78bc332b7868397b835c8317ac47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the reference count of the scheme.  <a href="classt8__scheme.html#a4d3a78bc332b7868397b835c8317ac47">More...</a><br /></td></tr>
<tr class="separator:a4d3a78bc332b7868397b835c8317ac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d98eada4c87673a7c189a5b2a1cb7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ad1d98eada4c87673a7c189a5b2a1cb7e">get_num_eclass_schemes</a> () const</td></tr>
<tr class="memdesc:ad1d98eada4c87673a7c189a5b2a1cb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of eclass schemes inside the scheme.  <a href="classt8__scheme.html#ad1d98eada4c87673a7c189a5b2a1cb7e">More...</a><br /></td></tr>
<tr class="separator:ad1d98eada4c87673a7c189a5b2a1cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cfd761c91248b59ce42902addacdd"><td class="memTemplParams" colspan="2">template&lt;class TEclassScheme &gt; </td></tr>
<tr class="memitem:ab26cfd761c91248b59ce42902addacdd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab26cfd761c91248b59ce42902addacdd">check_eclass_scheme_type</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:ab26cfd761c91248b59ce42902addacdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the scheme is of a specific type.  <a href="classt8__scheme.html#ab26cfd761c91248b59ce42902addacdd">More...</a><br /></td></tr>
<tr class="separator:ab26cfd761c91248b59ce42902addacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e212bb5f95d9e07e65b54c911d2c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a41e212bb5f95d9e07e65b54c911d2c71">get_eclass_scheme_eclass</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a41e212bb5f95d9e07e65b54c911d2c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eclass an eclass scheme is valid for.  <a href="classt8__scheme.html#a41e212bb5f95d9e07e65b54c911d2c71">More...</a><br /></td></tr>
<tr class="separator:a41e212bb5f95d9e07e65b54c911d2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6c4d7de5838d2a7bf7f99c29467533"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a2b6c4d7de5838d2a7bf7f99c29467533">get_element_size</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a2b6c4d7de5838d2a7bf7f99c29467533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of any element of a given class.  <a href="classt8__scheme.html#a2b6c4d7de5838d2a7bf7f99c29467533">More...</a><br /></td></tr>
<tr class="separator:a2b6c4d7de5838d2a7bf7f99c29467533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585e34278986190d562fa76c47d6470"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5585e34278986190d562fa76c47d6470">refines_irregular</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a5585e34278986190d562fa76c47d6470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if there is one element in the tree, that does not refine into 2^dim children.  <a href="classt8__scheme.html#a5585e34278986190d562fa76c47d6470">More...</a><br /></td></tr>
<tr class="separator:a5585e34278986190d562fa76c47d6470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ad9586fb7839910813418b6e5b22a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a42ad9586fb7839910813418b6e5b22a6">get_maxlevel</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a42ad9586fb7839910813418b6e5b22a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowed level for any element of a given class.  <a href="classt8__scheme.html#a42ad9586fb7839910813418b6e5b22a6">More...</a><br /></td></tr>
<tr class="separator:a42ad9586fb7839910813418b6e5b22a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1f54d8d0ea2a2b3047527be726113f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a1b1f54d8d0ea2a2b3047527be726113f">element_get_level</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a1b1f54d8d0ea2a2b3047527be726113f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of a particular element.  <a href="classt8__scheme.html#a1b1f54d8d0ea2a2b3047527be726113f">More...</a><br /></td></tr>
<tr class="separator:a1b1f54d8d0ea2a2b3047527be726113f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab976202bc88eceaf814568eb81dc5e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab976202bc88eceaf814568eb81dc5e7f">element_copy</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *source, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *dest) const</td></tr>
<tr class="memdesc:ab976202bc88eceaf814568eb81dc5e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all entries of <em>source</em> to <em>dest</em>.  <a href="classt8__scheme.html#ab976202bc88eceaf814568eb81dc5e7f">More...</a><br /></td></tr>
<tr class="separator:ab976202bc88eceaf814568eb81dc5e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6c2a91780403d2765bfc222098ba6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#acc6c2a91780403d2765bfc222098ba6c">element_compare</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) const</td></tr>
<tr class="memdesc:acc6c2a91780403d2765bfc222098ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two elements.  <a href="classt8__scheme.html#acc6c2a91780403d2765bfc222098ba6c">More...</a><br /></td></tr>
<tr class="separator:acc6c2a91780403d2765bfc222098ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be24712101df44758b98fe8ae3eda27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a7be24712101df44758b98fe8ae3eda27">element_is_equal</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) const</td></tr>
<tr class="memdesc:a7be24712101df44758b98fe8ae3eda27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are equal.  <a href="classt8__scheme.html#a7be24712101df44758b98fe8ae3eda27">More...</a><br /></td></tr>
<tr class="separator:a7be24712101df44758b98fe8ae3eda27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d07600af208fd89522714cde6783939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a1d07600af208fd89522714cde6783939">element_is_refinable</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a1d07600af208fd89522714cde6783939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if an element is refinable.  <a href="classt8__scheme.html#a1d07600af208fd89522714cde6783939">More...</a><br /></td></tr>
<tr class="separator:a1d07600af208fd89522714cde6783939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645f2e1718914dff93879d584a952def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a645f2e1718914dff93879d584a952def">element_get_parent</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *parent) const</td></tr>
<tr class="memdesc:a645f2e1718914dff93879d584a952def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the parent of a given element <em>element</em> and store it in <em>parent</em>.  <a href="classt8__scheme.html#a645f2e1718914dff93879d584a952def">More...</a><br /></td></tr>
<tr class="separator:a645f2e1718914dff93879d584a952def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e0fbf4c295b6729d7fbe758b2f559d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a81e0fbf4c295b6729d7fbe758b2f559d">element_get_num_siblings</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a81e0fbf4c295b6729d7fbe758b2f559d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of siblings of an element.  <a href="classt8__scheme.html#a81e0fbf4c295b6729d7fbe758b2f559d">More...</a><br /></td></tr>
<tr class="separator:a81e0fbf4c295b6729d7fbe758b2f559d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c58f016767f120f345cc1cdaffcef0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5c58f016767f120f345cc1cdaffcef0a">element_get_sibling</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int sibid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *sibling) const</td></tr>
<tr class="memdesc:a5c58f016767f120f345cc1cdaffcef0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a specific sibling of a given element <em>element</em> and store it in <em>sibling</em>.  <a href="classt8__scheme.html#a5c58f016767f120f345cc1cdaffcef0a">More...</a><br /></td></tr>
<tr class="separator:a5c58f016767f120f345cc1cdaffcef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59be9014021fbc3fccb512316e6bd311"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a59be9014021fbc3fccb512316e6bd311">element_get_num_corners</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a59be9014021fbc3fccb512316e6bd311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of corners of a given element.  <a href="classt8__scheme.html#a59be9014021fbc3fccb512316e6bd311">More...</a><br /></td></tr>
<tr class="separator:a59be9014021fbc3fccb512316e6bd311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab285ae6c290cc179a7bf8536978704f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab285ae6c290cc179a7bf8536978704f7">element_get_num_faces</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:ab285ae6c290cc179a7bf8536978704f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of faces of a given element.  <a href="classt8__scheme.html#ab285ae6c290cc179a7bf8536978704f7">More...</a><br /></td></tr>
<tr class="separator:ab285ae6c290cc179a7bf8536978704f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d70f074e263c0e31ff1d2154a11682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a55d70f074e263c0e31ff1d2154a11682">element_get_max_num_faces</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a55d70f074e263c0e31ff1d2154a11682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of faces of a given element and all of its descendants.  <a href="classt8__scheme.html#a55d70f074e263c0e31ff1d2154a11682">More...</a><br /></td></tr>
<tr class="separator:a55d70f074e263c0e31ff1d2154a11682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c393503517d53bbc2c224502e91087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab1c393503517d53bbc2c224502e91087">element_get_num_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:ab1c393503517d53bbc2c224502e91087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element when it is refined.  <a href="classt8__scheme.html#ab1c393503517d53bbc2c224502e91087">More...</a><br /></td></tr>
<tr class="separator:ab1c393503517d53bbc2c224502e91087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20feb307512cb9a2f9bc93fcf628cdfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a20feb307512cb9a2f9bc93fcf628cdfc">get_max_num_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class) const</td></tr>
<tr class="memdesc:a20feb307512cb9a2f9bc93fcf628cdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the max number of children of an eclass.  <a href="classt8__scheme.html#a20feb307512cb9a2f9bc93fcf628cdfc">More...</a><br /></td></tr>
<tr class="separator:a20feb307512cb9a2f9bc93fcf628cdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82e4f33d8875656f9c533e2c77564b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ae82e4f33d8875656f9c533e2c77564b0">element_get_num_face_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face) const</td></tr>
<tr class="memdesc:ae82e4f33d8875656f9c533e2c77564b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element's face when the element is refined.  <a href="classt8__scheme.html#ae82e4f33d8875656f9c533e2c77564b0">More...</a><br /></td></tr>
<tr class="separator:ae82e4f33d8875656f9c533e2c77564b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9253b553272dd2e966395eeb9f19f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a14d9253b553272dd2e966395eeb9f19f">element_get_face_corner</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, const int corner) const</td></tr>
<tr class="memdesc:a14d9253b553272dd2e966395eeb9f19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corner number of an element's face corner.  <a href="classt8__scheme.html#a14d9253b553272dd2e966395eeb9f19f">More...</a><br /></td></tr>
<tr class="separator:a14d9253b553272dd2e966395eeb9f19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68809126cb1bab4401d306663db4f8c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a68809126cb1bab4401d306663db4f8c8">element_get_corner_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int corner, const int face) const</td></tr>
<tr class="memdesc:a68809126cb1bab4401d306663db4f8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the face numbers of the faces sharing an element's corner.  <a href="classt8__scheme.html#a68809126cb1bab4401d306663db4f8c8">More...</a><br /></td></tr>
<tr class="separator:a68809126cb1bab4401d306663db4f8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9aff2ae346164cf0d008934d77f341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ada9aff2ae346164cf0d008934d77f341">element_get_child</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int childid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *child) const</td></tr>
<tr class="memdesc:ada9aff2ae346164cf0d008934d77f341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the child element of a given number.  <a href="classt8__scheme.html#ada9aff2ae346164cf0d008934d77f341">More...</a><br /></td></tr>
<tr class="separator:ada9aff2ae346164cf0d008934d77f341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86374c8e9f312cda54abb0ef80058a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ad86374c8e9f312cda54abb0ef80058a1">element_get_children</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *c[]) const</td></tr>
<tr class="memdesc:ad86374c8e9f312cda54abb0ef80058a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct all children of a given element.  <a href="classt8__scheme.html#ad86374c8e9f312cda54abb0ef80058a1">More...</a><br /></td></tr>
<tr class="separator:ad86374c8e9f312cda54abb0ef80058a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98587c124a395d16b3c40f2a8553e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa98587c124a395d16b3c40f2a8553e84">element_get_child_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:aa98587c124a395d16b3c40f2a8553e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the child id of an element.  <a href="classt8__scheme.html#aa98587c124a395d16b3c40f2a8553e84">More...</a><br /></td></tr>
<tr class="separator:aa98587c124a395d16b3c40f2a8553e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9120ae6798608cc78e119275526dff0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa9120ae6798608cc78e119275526dff0">element_get_ancestor_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int level) const</td></tr>
<tr class="memdesc:aa9120ae6798608cc78e119275526dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ancestor id of an element, that is the child id at a given level.  <a href="classt8__scheme.html#aa9120ae6798608cc78e119275526dff0">More...</a><br /></td></tr>
<tr class="separator:aa9120ae6798608cc78e119275526dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a0afde9fa6e9dda13e2bc33e403df2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a79a0afde9fa6e9dda13e2bc33e403df2">elements_are_family</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *fam) const</td></tr>
<tr class="memdesc:a79a0afde9fa6e9dda13e2bc33e403df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given set of elements is a family or not.  <a href="classt8__scheme.html#a79a0afde9fa6e9dda13e2bc33e403df2">More...</a><br /></td></tr>
<tr class="separator:a79a0afde9fa6e9dda13e2bc33e403df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db4f6029b2cacb3b3fd2ad4d12a4b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5db4f6029b2cacb3b3fd2ad4d12a4b8b">element_get_nca</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const nca) const</td></tr>
<tr class="memdesc:a5db4f6029b2cacb3b3fd2ad4d12a4b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nearest common ancestor of two elements.  <a href="classt8__scheme.html#a5db4f6029b2cacb3b3fd2ad4d12a4b8b">More...</a><br /></td></tr>
<tr class="separator:a5db4f6029b2cacb3b3fd2ad4d12a4b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4b60f238a6d6770a24db8e5f56158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a20a4b60f238a6d6770a24db8e5f56158">element_get_face_shape</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face) const</td></tr>
<tr class="memdesc:a20a4b60f238a6d6770a24db8e5f56158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shape of the face of an element.  <a href="classt8__scheme.html#a20a4b60f238a6d6770a24db8e5f56158">More...</a><br /></td></tr>
<tr class="separator:a20a4b60f238a6d6770a24db8e5f56158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92555d468f7fb017d57fe17fe607e840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a92555d468f7fb017d57fe17fe607e840">element_get_children_at_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *children[], int num_children, int *child_indices) const</td></tr>
<tr class="memdesc:a92555d468f7fb017d57fe17fe607e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of the element, compute all children of the element that touch the face.  <a href="classt8__scheme.html#a92555d468f7fb017d57fe17fe607e840">More...</a><br /></td></tr>
<tr class="separator:a92555d468f7fb017d57fe17fe607e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889e5d4a9d2e96b23c7d839466093f15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a889e5d4a9d2e96b23c7d839466093f15">element_face_get_child_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, const int face_child) const</td></tr>
<tr class="memdesc:a889e5d4a9d2e96b23c7d839466093f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face.  <a href="classt8__scheme.html#a889e5d4a9d2e96b23c7d839466093f15">More...</a><br /></td></tr>
<tr class="separator:a889e5d4a9d2e96b23c7d839466093f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1546fef4d5003e7bd15591b95675ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#afa1546fef4d5003e7bd15591b95675ec">element_face_get_parent_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face) const</td></tr>
<tr class="memdesc:afa1546fef4d5003e7bd15591b95675ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element return the face number of the parent of the element that matches the element's face.  <a href="classt8__scheme.html#afa1546fef4d5003e7bd15591b95675ec">More...</a><br /></td></tr>
<tr class="separator:afa1546fef4d5003e7bd15591b95675ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba643bc60832f25a9c145d687bef9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a58ba643bc60832f25a9c145d687bef9c">element_get_tree_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face) const</td></tr>
<tr class="memdesc:a58ba643bc60832f25a9c145d687bef9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of this element.  <a href="classt8__scheme.html#a58ba643bc60832f25a9c145d687bef9c">More...</a><br /></td></tr>
<tr class="separator:a58ba643bc60832f25a9c145d687bef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54cbd6c146c7b93ac4a8cf65efb7079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa54cbd6c146c7b93ac4a8cf65efb7079">element_transform_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, const int orientation, const int sign, const int is_smaller_face) const</td></tr>
<tr class="memdesc:aa54cbd6c146c7b93ac4a8cf65efb7079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we have two trees that share a common face f.  <a href="classt8__scheme.html#aa54cbd6c146c7b93ac4a8cf65efb7079">More...</a><br /></td></tr>
<tr class="separator:aa54cbd6c146c7b93ac4a8cf65efb7079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9609eb1796a654291d291865627cdf67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a9609eb1796a654291d291865627cdf67">element_extrude_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int root_face) const</td></tr>
<tr class="memdesc:a9609eb1796a654291d291865627cdf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face.  <a href="classt8__scheme.html#a9609eb1796a654291d291865627cdf67">More...</a><br /></td></tr>
<tr class="separator:a9609eb1796a654291d291865627cdf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203832bb391d223446f1b7d3a4052a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a203832bb391d223446f1b7d3a4052a15">element_get_boundary_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *boundary) const</td></tr>
<tr class="memdesc:a203832bb391d223446f1b7d3a4052a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the boundary element at a specific face.  <a href="classt8__scheme.html#a203832bb391d223446f1b7d3a4052a15">More...</a><br /></td></tr>
<tr class="separator:a203832bb391d223446f1b7d3a4052a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924aa2df03814dac1ffacc89ccdf28df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a924aa2df03814dac1ffacc89ccdf28df">element_get_first_descendant_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *first_desc, const int level) const</td></tr>
<tr class="memdesc:a924aa2df03814dac1ffacc89ccdf28df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the first descendant of an element at a given level that touches a given face.  <a href="classt8__scheme.html#a924aa2df03814dac1ffacc89ccdf28df">More...</a><br /></td></tr>
<tr class="separator:a924aa2df03814dac1ffacc89ccdf28df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730f0bd1402e7532d1272e3911cb1dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a730f0bd1402e7532d1272e3911cb1dbe">element_get_last_descendant_face</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *last_desc, const int level) const</td></tr>
<tr class="memdesc:a730f0bd1402e7532d1272e3911cb1dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the last descendant of an element at a given level that touches a given face.  <a href="classt8__scheme.html#a730f0bd1402e7532d1272e3911cb1dbe">More...</a><br /></td></tr>
<tr class="separator:a730f0bd1402e7532d1272e3911cb1dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299fa2b44f16d5ded89713dc97cc379"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a3299fa2b44f16d5ded89713dc97cc379">element_is_root_boundary</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face) const</td></tr>
<tr class="memdesc:a3299fa2b44f16d5ded89713dc97cc379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether a given element shares a given face with its root tree.  <a href="classt8__scheme.html#a3299fa2b44f16d5ded89713dc97cc379">More...</a><br /></td></tr>
<tr class="separator:a3299fa2b44f16d5ded89713dc97cc379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beb07b93dfb56f86902c814b37ae1b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a1beb07b93dfb56f86902c814b37ae1b2">element_get_face_neighbor_inside</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *neigh, const int face, int *neigh_face) const</td></tr>
<tr class="memdesc:a1beb07b93dfb56f86902c814b37ae1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the face neighbor of a given element if this face neighbor is inside the root tree.  <a href="classt8__scheme.html#a1beb07b93dfb56f86902c814b37ae1b2">More...</a><br /></td></tr>
<tr class="separator:a1beb07b93dfb56f86902c814b37ae1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5af164747049d6f5a350bb317fe57d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac5af164747049d6f5a350bb317fe57d8">element_get_shape</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:ac5af164747049d6f5a350bb317fe57d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape of an allocated element according its type.  <a href="classt8__scheme.html#ac5af164747049d6f5a350bb317fe57d8">More...</a><br /></td></tr>
<tr class="separator:ac5af164747049d6f5a350bb317fe57d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942750e63d9374d877d97ca6d4a5e028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a942750e63d9374d877d97ca6d4a5e028">element_set_linear_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int level, const <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> id) const</td></tr>
<tr class="memdesc:a942750e63d9374d877d97ca6d4a5e028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the entries of an allocated element according to a given linear id in a uniform refinement.  <a href="classt8__scheme.html#a942750e63d9374d877d97ca6d4a5e028">More...</a><br /></td></tr>
<tr class="separator:a942750e63d9374d877d97ca6d4a5e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484fb1aa29ce7410876d1c26ff6b203b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a484fb1aa29ce7410876d1c26ff6b203b">element_get_linear_id</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int level) const</td></tr>
<tr class="memdesc:a484fb1aa29ce7410876d1c26ff6b203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear id of a given element in a hypothetical uniform refinement of a given level.  <a href="classt8__scheme.html#a484fb1aa29ce7410876d1c26ff6b203b">More...</a><br /></td></tr>
<tr class="separator:a484fb1aa29ce7410876d1c26ff6b203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bd0084ceee8bdae81c89abd35e0ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a68bd0084ceee8bdae81c89abd35e0ff9">element_get_first_descendant</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, const int level) const</td></tr>
<tr class="memdesc:a68bd0084ceee8bdae81c89abd35e0ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first descendant of a given element.  <a href="classt8__scheme.html#a68bd0084ceee8bdae81c89abd35e0ff9">More...</a><br /></td></tr>
<tr class="separator:a68bd0084ceee8bdae81c89abd35e0ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f9625dd624c96b5051d1330cb45f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a39f9625dd624c96b5051d1330cb45f54">element_get_last_descendant</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, const int level) const</td></tr>
<tr class="memdesc:a39f9625dd624c96b5051d1330cb45f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the last descendant of a given element.  <a href="classt8__scheme.html#a39f9625dd624c96b5051d1330cb45f54">More...</a><br /></td></tr>
<tr class="separator:a39f9625dd624c96b5051d1330cb45f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d5a64442ac19361b96b59a4626a2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ab4d5a64442ac19361b96b59a4626a2f4">element_construct_successor</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *successor) const</td></tr>
<tr class="memdesc:ab4d5a64442ac19361b96b59a4626a2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the successor in a uniform refinement of a given element.  <a href="classt8__scheme.html#ab4d5a64442ac19361b96b59a4626a2f4">More...</a><br /></td></tr>
<tr class="separator:ab4d5a64442ac19361b96b59a4626a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad365c3e5f3363939c98662d42765e220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ad365c3e5f3363939c98662d42765e220">element_get_vertex_reference_coords</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int vertex, double coords[]) const</td></tr>
<tr class="memdesc:ad365c3e5f3363939c98662d42765e220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension).  <a href="classt8__scheme.html#ad365c3e5f3363939c98662d42765e220">More...</a><br /></td></tr>
<tr class="separator:ad365c3e5f3363939c98662d42765e220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a56f18647c64ad7f164b46d4b15789f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a2a56f18647c64ad7f164b46d4b15789f">element_get_reference_coords</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const double *ref_coords, const size_t num_coords, double *out_coords) const</td></tr>
<tr class="memdesc:a2a56f18647c64ad7f164b46d4b15789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points in the reference space of an element to points in the reference space of the tree.  <a href="classt8__scheme.html#a2a56f18647c64ad7f164b46d4b15789f">More...</a><br /></td></tr>
<tr class="separator:a2a56f18647c64ad7f164b46d4b15789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be187f0be562e3e2d899f05c9709826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a9be187f0be562e3e2d899f05c9709826">element_count_leaves</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *t, const int level) const</td></tr>
<tr class="memdesc:a9be187f0be562e3e2d899f05c9709826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level an element would produce.  <a href="classt8__scheme.html#a9be187f0be562e3e2d899f05c9709826">More...</a><br /></td></tr>
<tr class="separator:a9be187f0be562e3e2d899f05c9709826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db97e764b0195c22006227874d24afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a5db97e764b0195c22006227874d24afd">count_leaves_from_root</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int level) const</td></tr>
<tr class="memdesc:a5db97e764b0195c22006227874d24afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level the root element will produce.  <a href="classt8__scheme.html#a5db97e764b0195c22006227874d24afd">More...</a><br /></td></tr>
<tr class="separator:a5db97e764b0195c22006227874d24afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d3891804730d35c64a96672669dc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a182d3891804730d35c64a96672669dc4">element_is_valid</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a182d3891804730d35c64a96672669dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it.  <a href="classt8__scheme.html#a182d3891804730d35c64a96672669dc4">More...</a><br /></td></tr>
<tr class="separator:a182d3891804730d35c64a96672669dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c419d98e6e3c1d7bef9d76d172fb4a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a9c419d98e6e3c1d7bef9d76d172fb4a5">element_debug_print</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:a9c419d98e6e3c1d7bef9d76d172fb4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a given element.  <a href="classt8__scheme.html#a9c419d98e6e3c1d7bef9d76d172fb4a5">More...</a><br /></td></tr>
<tr class="separator:a9c419d98e6e3c1d7bef9d76d172fb4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021be34142b77ebe52cf7c66c52a4b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a021be34142b77ebe52cf7c66c52a4b63">element_to_string</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, char *debug_string, const int string_size) const</td></tr>
<tr class="memdesc:a021be34142b77ebe52cf7c66c52a4b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a string with readable information about the element.  <a href="classt8__scheme.html#a021be34142b77ebe52cf7c66c52a4b63">More...</a><br /></td></tr>
<tr class="separator:a021be34142b77ebe52cf7c66c52a4b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4558193fa50f52a1d4face143ee8c69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elements) const</td></tr>
<tr class="memdesc:a4558193fa50f52a1d4face143ee8c69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>length</em> many elements of a given class and initialize them, and put pointers to the elements in the provided array.  <a href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">More...</a><br /></td></tr>
<tr class="separator:a4558193fa50f52a1d4face143ee8c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbfe71ec23ec01d916064f660559de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elements) const</td></tr>
<tr class="memdesc:a2fbfe71ec23ec01d916064f660559de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of allocated elements.  <a href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">More...</a><br /></td></tr>
<tr class="separator:a2fbfe71ec23ec01d916064f660559de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54694a54ba6b9e1860dc516e41fb3450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a54694a54ba6b9e1860dc516e41fb3450">element_deinit</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elements) const</td></tr>
<tr class="memdesc:a54694a54ba6b9e1860dc516e41fb3450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize an array of allocated elements.  <a href="classt8__scheme.html#a54694a54ba6b9e1860dc516e41fb3450">More...</a><br /></td></tr>
<tr class="separator:a54694a54ba6b9e1860dc516e41fb3450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0312e24e6ed4658e5c690fab482d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a6e0312e24e6ed4658e5c690fab482d62">element_destroy</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elements) const</td></tr>
<tr class="memdesc:a6e0312e24e6ed4658e5c690fab482d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate an array of elements.  <a href="classt8__scheme.html#a6e0312e24e6ed4658e5c690fab482d62">More...</a><br /></td></tr>
<tr class="separator:a6e0312e24e6ed4658e5c690fab482d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac981f585dda62a3a8613b04c096195eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#ac981f585dda62a3a8613b04c096195eb">set_to_root</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:ac981f585dda62a3a8613b04c096195eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">create the root element  <a href="classt8__scheme.html#ac981f585dda62a3a8613b04c096195eb">More...</a><br /></td></tr>
<tr class="separator:ac981f585dda62a3a8613b04c096195eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e3c7a9f56253e11e36156e3cd52a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a42e3c7a9f56253e11e36156e3cd52a8f">element_MPI_Pack</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const elements, const unsigned int count, void *send_buffer, int buffer_size, int *position, sc_MPI_Comm comm) const</td></tr>
<tr class="memdesc:a42e3c7a9f56253e11e36156e3cd52a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack multiple elements into contiguous memory, so they can be sent via MPI.  <a href="classt8__scheme.html#a42e3c7a9f56253e11e36156e3cd52a8f">More...</a><br /></td></tr>
<tr class="separator:a42e3c7a9f56253e11e36156e3cd52a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66cf5e55cb110aafd7249689850936e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#aa66cf5e55cb110aafd7249689850936e">element_MPI_Pack_size</a> (const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, const unsigned int count, sc_MPI_Comm comm, int *pack_size) const</td></tr>
<tr class="memdesc:aa66cf5e55cb110aafd7249689850936e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine an upper bound for the size of the packed message of <em>count</em> elements.  <a href="classt8__scheme.html#aa66cf5e55cb110aafd7249689850936e">More...</a><br /></td></tr>
<tr class="separator:aa66cf5e55cb110aafd7249689850936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6038aefd4b83edc4325c590cc5ad3e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__scheme.html#a6038aefd4b83edc4325c590cc5ad3e74">element_MPI_Unpack</a> (<a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> tree_class, void *recvbuf, const int buffer_size, int *position, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elements, const unsigned int count, sc_MPI_Comm comm) const</td></tr>
<tr class="memdesc:a6038aefd4b83edc4325c590cc5ad3e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack multiple elements from contiguous memory that was received via MPI.  <a href="classt8__scheme.html#a6038aefd4b83edc4325c590cc5ad3e74">More...</a><br /></td></tr>
<tr class="separator:a6038aefd4b83edc4325c590cc5ad3e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afea6512ca68ced2086be8bb24e948a97"><td class="memItemLeft" align="right" valign="top"><a id="afea6512ca68ced2086be8bb24e948a97"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>t8_scheme_builder</b></td></tr>
<tr class="separator:afea6512ca68ced2086be8bb24e948a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class holds one or more element schemes. </p>
<p>It also relays the function calls to the specific schemes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab26cfd761c91248b59ce42902addacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cfd761c91248b59ce42902addacdd">&#9670;&nbsp;</a></span>check_eclass_scheme_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEclassScheme &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::check_eclass_scheme_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the scheme is of a specific type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEclass_Scheme</td><td>The type of the scheme to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the scheme is of type <em>TEclassScheme</em>, false otherwise. </dd></dl>

</div>
</div>
<a id="a5db97e764b0195c22006227874d24afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db97e764b0195c22006227874d24afd">&#9670;&nbsp;</a></span>count_leaves_from_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> t8_scheme::count_leaves_from_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level the root element will produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="t8__scheme_8h.html#acce8f7fe7d7665529976e43cf71e8d48">t8_element_count_leaves</a> if the input element is the root (level 0) element.</dd></dl>
<p>This is a convenience function, and can be implemented via <a class="el" href="t8__scheme_8h.html#acce8f7fe7d7665529976e43cf71e8d48">t8_element_count_leaves</a>. </p>

</div>
</div>
<a id="acc6c2a91780403d2765bfc222098ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6c2a91780403d2765bfc222098ba6c">&#9670;&nbsp;</a></span>element_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative if elem1 &lt; elem2, zero if elem1 equals elem2 and positive if elem1 &gt; elem2. If elem2 is a copy of elem1 then the elements are equal. </dd></dl>

</div>
</div>
<a id="ab4d5a64442ac19361b96b59a4626a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d5a64442ac19361b96b59a4626a2f4">&#9670;&nbsp;</a></span>element_construct_successor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_construct_successor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>successor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the successor in a uniform refinement of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose successor should be constructed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">successor</td><td>The element whose entries will be set to the successor of <em>element</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab976202bc88eceaf814568eb81dc5e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab976202bc88eceaf814568eb81dc5e7f">&#9670;&nbsp;</a></span>element_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all entries of <em>source</em> to <em>dest</em>. </p>
<p><em>dest</em> must be an existing element. No memory is allocated by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The element whose entries will be copied to <em>dest</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>This element's entries will be overwritten with the entries of <em>source</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>source</em> and <em>dest</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a9be187f0be562e3e2d899f05c9709826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be187f0be562e3e2d899f05c9709826">&#9670;&nbsp;</a></span>element_count_leaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> t8_scheme::element_count_leaves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level an element would produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The element to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Suppose <em>t</em> is uniformly refined up to level <em>level</em>. The return value is the resulting number of elements (of the given level). If <em>level</em> &lt; element_get_level(t), the return value should be 0.</dd></dl>
<p>Example: If <em>t</em> is a line element that refines into 2 line elements on each level, then the return value is max(0, 2^{<em>level</em> - level(<em>t</em>)}). Thus, if <em>t's</em> level is 0, and <em>level</em> = 3, the return value is 2^3 = 8. </p>

</div>
</div>
<a id="a9c419d98e6e3c1d7bef9d76d172fb4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c419d98e6e3c1d7bef9d76d172fb4a5">&#9670;&nbsp;</a></span>element_debug_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_debug_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a given element. </p>
<p>For a example for a triangle print the coordinates and the level of the triangle. This function is only available in the debugging configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54694a54ba6b9e1860dc516e41fb3450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54694a54ba6b9e1860dc516e41fb3450">&#9670;&nbsp;</a></span>element_deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_deinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize an array of allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be deinitialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>On input an array of <em>length</em> many allocated and initialized elements, on output an array of <em>length</em> many allocated, but not initialized elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Call this function if you called <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> on the element pointers. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5" title="Initialize an array of allocated elements.">element_init</a> </dd></dl>

</div>
</div>
<a id="a6e0312e24e6ed4658e5c690fab482d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0312e24e6ed4658e5c690fab482d62">&#9670;&nbsp;</a></span>element_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate an array of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>On input an array of <em>length</em> many allocated element pointers. On output all these pointers will be freed. <em>element</em> itself will not be freed by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b" title="Allocate memory for length many elements of a given class and initialize them, and put pointers to th...">element_new</a> </dd></dl>

</div>
</div>
<a id="a9609eb1796a654291d291865627cdf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9609eb1796a654291d291865627cdf67">&#9670;&nbsp;</a></span>element_extrude_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_extrude_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>root_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">element</td><td>An allocated element. The entries will be filled with the data of the element that has <em>face</em> as a face and lies within the root tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_face</td><td>The index of the face of the root tree in which <em>face</em> lies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of <em>element</em> that coincides with <em>face</em>. </dd></dl>

</div>
</div>
<a id="a889e5d4a9d2e96b23c7d839466093f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889e5d4a9d2e96b23c7d839466093f15">&#9670;&nbsp;</a></span>element_face_get_child_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_face_get_child_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face. </p>
<pre class="fragment"> x ---- x   x      x           x ---- x
 |      |   |      |           |   |  | &lt;-- f
 |      |   |      x           |   x--x
 |      |   |                  |      |
 x ---- x   x                  x ---- x
  element    face  face_child    Returns the face number f
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_child</td><td>A number 0 &lt;= <em>face_child</em> &lt; num_face_children, specifying a child of <em>element</em> that shares a face with <em>face</em>. These children are counted in linear order. This coincides with the order of children from a call to <a class="el" href="classt8__scheme.html#a92555d468f7fb017d57fe17fe607e840">element_get_children_at_face</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of a child of <em>element</em> that coincides with <em>face_child</em>. </dd></dl>

</div>
</div>
<a id="afa1546fef4d5003e7bd15591b95675ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1546fef4d5003e7bd15591b95675ec">&#9670;&nbsp;</a></span>element_face_get_parent_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_face_get_parent_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a face of an element return the face number of the parent of the element that matches the element's face. </p>
<p>Or return -1 if no face of the parent matches the face. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>face</em> of <em>element</em> is also a face of <em>element's</em> parent, the face number of this face. Otherwise -1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For the root element this function always returns <em>face</em>. </dd></dl>

</div>
</div>
<a id="aa9120ae6798608cc78e119275526dff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9120ae6798608cc78e119275526dff0">&#9670;&nbsp;</a></span>element_get_ancestor_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_ancestor_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the ancestor id of an element, that is the child id at a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>This must be a valid element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. Must satisfy <em>level</em> &lt;= element.level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child_id of <em>element</em> in regard to its <em>level</em> ancestor. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ancestor id at element.level is the same as the child id. </dd></dl>

</div>
</div>
<a id="a203832bb391d223446f1b7d3a4052a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203832bb391d223446f1b7d3a4052a15">&#9670;&nbsp;</a></span>element_get_boundary_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_boundary_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the boundary element at a specific face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face of which to construct the boundary element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundary</td><td>An allocated element of dimension of <em>element</em> minus 1. The entries will be filled with the entries of the face of <em>element</em>. If <em>element</em> is of class T8_ECLASS_VERTEX, then <em>boundary</em> must be NULL and will not be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9aff2ae346164cf0d008934d77f341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9aff2ae346164cf0d008934d77f341">&#9670;&nbsp;</a></span>element_get_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>childid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the child element of a given number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childid</td><td>The number of the child to construct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child</td><td>The storage for this element must exist. On output, a valid element. It is valid to call this function with element = child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa98587c124a395d16b3c40f2a8553e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98587c124a395d16b3c40f2a8553e84">&#9670;&nbsp;</a></span>element_get_child_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_child_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the child id of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>This must be a valid element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id of element. </dd></dl>

</div>
</div>
<a id="ad86374c8e9f312cda54abb0ef80058a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86374c8e9f312cda54abb0ef80058a1">&#9670;&nbsp;</a></span>element_get_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct all children of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the output array <em>c</em> must match the number of children. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The storage for these <em>length</em> elements must exist. On output, all children are valid. It is valid to call this function with element = c[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__scheme.html#ab1c393503517d53bbc2c224502e91087" title="Return the number of children of an element when it is refined.">element_get_num_children</a> </dd></dl>

</div>
</div>
<a id="a92555d468f7fb017d57fe17fe607e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92555d468f7fb017d57fe17fe607e840">&#9670;&nbsp;</a></span>element_get_children_at_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_children_at_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>child_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an element and a face of the element, compute all children of the element that touch the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">children</td><td>Allocated elements, in which the children of <em>element</em> that share a face with <em>face</em> are stored. They will be stored in order of their linear id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_children</td><td>The number of elements in <em>children</em>. Must match the number of children that touch <em>face</em>. <a class="el" href="classt8__scheme.html#ae82e4f33d8875656f9c533e2c77564b0">element_get_num_face_children</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child_indices</td><td>If not NULL, an array of num_children integers must be given, on output its i-th entry is the child_id of the i-th face_child. It is valid to call this function with element = children[0]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68809126cb1bab4401d306663db4f8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68809126cb1bab4401d306663db4f8c8">&#9670;&nbsp;</a></span>element_get_corner_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_corner_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the face numbers of the faces sharing an element's corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 face 2 Thus for corner = 1 the output is: face=0 : 2, face=1: 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>corner</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the <em>face-th</em> face at <em>corner</em>. </dd></dl>

</div>
</div>
<a id="a14d9253b553272dd2e966395eeb9f19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d9253b553272dd2e966395eeb9f19f">&#9670;&nbsp;</a></span>element_get_face_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_face_corner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the corner number of an element's face corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 Thus for face = 1 the output is: corner=0 : 1, corner=1: 3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face 0 &lt;= <em>corner</em> &lt; num_face_corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner number of the <em>corner-th</em> vertex of <em>face</em>. </dd></dl>

</div>
</div>
<a id="a1beb07b93dfb56f86902c814b37ae1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1beb07b93dfb56f86902c814b37ae1b2">&#9670;&nbsp;</a></span>element_get_face_neighbor_inside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_face_neighbor_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>neigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neigh_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the face neighbor of a given element if this face neighbor is inside the root tree. </p>
<p>Return 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh</td><td>If the face neighbor of <em>element</em> along <em>face</em> is inside the root tree, this element's data is filled with the data of the face neighbor. Otherwise the data can be modified arbitrarily. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The number of the face along which the neighbor should be constructed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_face</td><td>The number of <em>face</em> as viewed from <em>neigh</em>. An arbitrary value, if the neighbor is not inside the root tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>neigh</em> is inside the root tree. False if not. In this case <em>neigh's</em> data can be arbitrary on output. </dd></dl>

</div>
</div>
<a id="a20a4b60f238a6d6770a24db8e5f56158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a4b60f238a6d6770a24db8e5f56158">&#9670;&nbsp;</a></span>element_get_face_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_scheme::element_get_face_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the shape of the face of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>element</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element shape of the face. I.e. T8_ECLASS_LINE for quads, T8_ECLASS_TRIANGLE for tets and depending on the face number either T8_ECLASS_QUAD or T8_ECLASS_TRIANGLE for prisms. </dd></dl>

</div>
</div>
<a id="a68bd0084ceee8bdae81c89abd35e0ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bd0084ceee8bdae81c89abd35e0ff9">&#9670;&nbsp;</a></span>element_get_first_descendant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_first_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the first descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The first element in a uniform refinement of <em>element</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a924aa2df03814dac1ffacc89ccdf28df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924aa2df03814dac1ffacc89ccdf28df">&#9670;&nbsp;</a></span>element_get_first_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_first_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>first_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the first descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first_desc</td><td>An allocated element. This element's data will be filled with the data of the first descendant of <em>element</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the first descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39f9625dd624c96b5051d1330cb45f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f9625dd624c96b5051d1330cb45f54">&#9670;&nbsp;</a></span>element_get_last_descendant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_last_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the last descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The last element in a uniform refinement of <em>element</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a730f0bd1402e7532d1272e3911cb1dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730f0bd1402e7532d1272e3911cb1dbe">&#9670;&nbsp;</a></span>element_get_last_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_last_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>last_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the last descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_desc</td><td>An allocated element. This element's data will be filled with the data of the last descendant of <em>element</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the last descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1f54d8d0ea2a2b3047527be726113f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1f54d8d0ea2a2b3047527be726113f">&#9670;&nbsp;</a></span>element_get_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the level of a particular element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose level should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a484fb1aa29ce7410876d1c26ff6b203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484fb1aa29ce7410876d1c26ff6b203b">&#9670;&nbsp;</a></span>element_get_linear_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> t8_scheme::element_get_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the linear id of a given element in a hypothetical uniform refinement of a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose id we compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the element. </dd></dl>

</div>
</div>
<a id="a55d70f074e263c0e31ff1d2154a11682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d70f074e263c0e31ff1d2154a11682">&#9670;&nbsp;</a></span>element_get_max_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_max_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the maximum number of faces of a given element and all of its descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of faces of <em>element</em> and its descendants. </dd></dl>

</div>
</div>
<a id="a5db4f6029b2cacb3b3fd2ad4d12a4b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db4f6029b2cacb3b3fd2ad4d12a4b8b">&#9670;&nbsp;</a></span>element_get_nca()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_nca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const&#160;</td>
          <td class="paramname"><em>nca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nearest common ancestor of two elements. </p>
<p>That is, the element with highest level that still has both given elements as descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first of the two input elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second of the two input elements. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nca</td><td>The storage for this element must exist and match the element class of the child. On output the unique nearest common ancestor of <em>elem1</em> and <em>elem2</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c393503517d53bbc2c224502e91087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c393503517d53bbc2c224502e91087">&#9670;&nbsp;</a></span>element_get_num_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children of an element when it is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose number of children is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>element</em> if it is to be refined. </dd></dl>

</div>
</div>
<a id="a59be9014021fbc3fccb512316e6bd311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59be9014021fbc3fccb512316e6bd311">&#9670;&nbsp;</a></span>element_get_num_corners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of corners of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of corners of <em>element</em>. </dd></dl>

</div>
</div>
<a id="ae82e4f33d8875656f9c533e2c77564b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82e4f33d8875656f9c533e2c77564b0">&#9670;&nbsp;</a></span>element_get_num_face_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_face_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children of an element's face when the element is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose face is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>element</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>face</em> if <em>element</em> is to be refined. </dd></dl>

</div>
</div>
<a id="ab285ae6c290cc179a7bf8536978704f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab285ae6c290cc179a7bf8536978704f7">&#9670;&nbsp;</a></span>element_get_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of faces of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a81e0fbf4c295b6729d7fbe758b2f559d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e0fbf4c295b6729d7fbe758b2f559d">&#9670;&nbsp;</a></span>element_get_num_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_num_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of siblings of an element. </p>
<p>That is the number of Children of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of siblings of <em>element</em>. Note that this number is &gt;= 1, since we count the element itself as a sibling. </dd></dl>

</div>
</div>
<a id="a645f2e1718914dff93879d584a952def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645f2e1718914dff93879d584a952def">&#9670;&nbsp;</a></span>element_get_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the parent of a given element <em>element</em> and store it in <em>parent</em>. </p>
<p><em>parent</em> needs to be an existing element. No memory is allocated by this function. <em>element</em> and <em>parent</em> can point to the same element, then the entries of <em>element</em> are overwritten by the ones of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose parent will be computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parent</td><td>This element's entries will be overwritten by those of <em>element's</em> parent. The storage for this element must exist and match the element class of the parent. For a pyramid, for example, it may be either a tetrahedron or a pyramid depending on <em>element's</em> childid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a56f18647c64ad7f164b46d4b15789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a56f18647c64ad7f164b46d4b15789f">&#9670;&nbsp;</a></span>element_get_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>ref_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert points in the reference space of an element to points in the reference space of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_coords</td><td>The coordinates \( [0,1]^\mathrm{dim} \) of the point in the reference space of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coords</td><td>Number of \( dim\)-sized coordinates to evaluate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_coords</td><td>The coordinates of the points in the reference space of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5af164747049d6f5a350bb317fe57d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5af164747049d6f5a350bb317fe57d8">&#9670;&nbsp;</a></span>element_get_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_scheme::element_get_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the shape of an allocated element according its type. </p>
<p>For example, a child of an element can be an element of a different shape and has to be handled differently - according to its shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the element as an eclass </dd></dl>

</div>
</div>
<a id="a5c58f016767f120f345cc1cdaffcef0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c58f016767f120f345cc1cdaffcef0a">&#9670;&nbsp;</a></span>element_get_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sibid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>sibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a specific sibling of a given element <em>element</em> and store it in <em>sibling</em>. </p>
<p><em>sibling</em> needs to be an existing element. No memory is allocated by this function. <em>element</em> and <em>sibling</em> can point to the same element, then the entries of <em>element</em> are overwritten by the ones of its sibid-th sibling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element whose sibling will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sibid</td><td>The id of the sibling computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sibling</td><td>This element's entries will be overwritten by those of <em>element's</em> sibid-th sibling. The storage for this element must exist and match the element class of the sibling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58ba643bc60832f25a9c145d687bef9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ba643bc60832f25a9c145d687bef9c">&#9670;&nbsp;</a></span>element_get_tree_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_get_tree_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an element and a face of this element. </p>
<p>If the face lies on the tree boundary, return the face number of the tree face. If not the return value is arbitrary. You can call <a class="el" href="classt8__scheme.html#a3299fa2b44f16d5ded89713dc97cc379">element_is_root_boundary</a> to query whether the face is at the tree boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of a face of <em>element</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the tree face that <em>face</em> is a subface of, if <em>face</em> is on a tree boundary. Any arbitrary integer if <em>is</em> not at a tree boundary. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value may look like a valid face of the tree even if the element does not lie on the root boundary. </dd></dl>

</div>
</div>
<a id="ad365c3e5f3363939c98662d42765e220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad365c3e5f3363939c98662d42765e220">&#9670;&nbsp;</a></span>element_get_vertex_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_get_vertex_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The id of the vertex whose coordinates shall be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>An array of at least as many doubles as the element's dimension whose entries will be filled with the coordinates of <em>vertex</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>coords should be zero-initialized, as only the first d coords will be set, but when used elsewhere all coords might be used. </dd></dl>

</div>
</div>
<a id="a2fbfe71ec23ec01d916064f660559de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbfe71ec23ec01d916064f660559de5">&#9670;&nbsp;</a></span>element_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be initialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>On input an array of <em>length</em> many allocated elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In debugging mode, an element that was passed to <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> must pass <a class="el" href="classt8__scheme.html#a182d3891804730d35c64a96672669dc4">element_is_valid</a>. </dd>
<dd>
If an element was created by <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> then <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> may not be called for it. Thus, <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> should initialize an element in the same way as a call to <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> would. </dd>
<dd>
Every call to <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> must be matched by a call to <a class="el" href="classt8__scheme.html#a54694a54ba6b9e1860dc516e41fb3450">element_deinit</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__scheme.html#a54694a54ba6b9e1860dc516e41fb3450" title="Deinitialize an array of allocated elements.">element_deinit</a> </dd>
<dd>
<a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b" title="Allocate memory for length many elements of a given class and initialize them, and put pointers to th...">element_new</a> </dd>
<dd>
<a class="el" href="classt8__scheme.html#a182d3891804730d35c64a96672669dc4" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">element_is_valid</a> </dd></dl>

</div>
</div>
<a id="a7be24712101df44758b98fe8ae3eda27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be24712101df44758b98fe8ae3eda27">&#9670;&nbsp;</a></span>element_is_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::element_is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two elements are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elements are equal, false if they are not equal </dd></dl>

</div>
</div>
<a id="a1d07600af208fd89522714cde6783939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d07600af208fd89522714cde6783939">&#9670;&nbsp;</a></span>element_is_refinable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::element_is_refinable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if an element is refinable. </p>
<p>Possible reasons for being not refinable could be that the element has reached its max level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element is refinable. </dd></dl>

</div>
</div>
<a id="a3299fa2b44f16d5ded89713dc97cc379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3299fa2b44f16d5ded89713dc97cc379">&#9670;&nbsp;</a></span>element_is_root_boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::element_is_root_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether a given element shares a given face with its root tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>element</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>face</em> is a subface of the element's root element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can compute the corresponding face number of the tree via <a class="el" href="classt8__scheme.html#a58ba643bc60832f25a9c145d687bef9c">element_get_tree_face</a>. </dd></dl>

</div>
</div>
<a id="a182d3891804730d35c64a96672669dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d3891804730d35c64a96672669dc4">&#9670;&nbsp;</a></span>element_is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::element_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it. </p>
<p>For example this could mean that all coordinates are in valid ranges and other membervariables do have meaningful values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>element</em> is safe to use. False otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>An element that is constructed with <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> must pass this test. </dd>
<dd>
An element for which <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> was called must pass this test. </dd>
<dd>
This function is used for debugging to catch certain errors. These can for example occur when an element points to a region of memory which should not be interpreted as an element. </dd>
<dd>
We recommend to use the assertion T8_ASSERT (element_is_valid (element)) in the implementation of each of the functions in this file. </dd></dl>

</div>
</div>
<a id="a42e3c7a9f56253e11e36156e3cd52a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e3c7a9f56253e11e36156e3cd52a8f">&#9670;&nbsp;</a></span>element_MPI_Pack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_MPI_Pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack multiple elements into contiguous memory, so they can be sent via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of elements that are to be packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">send_buffer</td><td>Buffer in which to pack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66cf5e55cb110aafd7249689850936e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66cf5e55cb110aafd7249689850936e">&#9670;&nbsp;</a></span>element_MPI_Pack_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_MPI_Pack_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine an upper bound for the size of the packed message of <em>count</em> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pack_size</td><td>upper bound on the message size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6038aefd4b83edc4325c590cc5ad3e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6038aefd4b83edc4325c590cc5ad3e74">&#9670;&nbsp;</a></span>element_MPI_Unpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_MPI_Unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack multiple elements from contiguous memory that was received via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvbuf</td><td>Buffer from which to unpack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of initialised elements that is to be filled from the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to unpack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4558193fa50f52a1d4face143ee8c69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4558193fa50f52a1d4face143ee8c69b">&#9670;&nbsp;</a></span>element_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>length</em> many elements of a given class and initialize them, and put pointers to the elements in the provided array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>On input an array of <em>length</em> many element pointers. On output all these pointers will point to an allocated and initialized element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There are two ways to create multiple elements of the same type. Create an array of element pointers and fill it with <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a>, or allocate memory for <em>length</em> times <em>element_size</em> many bytes, and fill them with element_init. To access a specific element, offset calculation needs to be done manually, as <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> is incomplete. </dd>
<dd>
In debugging mode, an element that was created with <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> must pass <a class="el" href="classt8__scheme.html#a182d3891804730d35c64a96672669dc4">element_is_valid</a> (for example the root element). </dd>
<dd>
If an element was created by <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> then <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> may not be called for it. Thus, <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> should initialize an element in the same way as a call to <a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5">element_init</a> would. </dd>
<dd>
Every call to <a class="el" href="classt8__scheme.html#a4558193fa50f52a1d4face143ee8c69b">element_new</a> must be matched by a call to <a class="el" href="classt8__scheme.html#a6e0312e24e6ed4658e5c690fab482d62">element_destroy</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__scheme.html#a6e0312e24e6ed4658e5c690fab482d62" title="Deallocate an array of elements.">element_destroy</a> </dd>
<dd>
<a class="el" href="classt8__scheme.html#a2fbfe71ec23ec01d916064f660559de5" title="Initialize an array of allocated elements.">element_init</a> </dd>
<dd>
<a class="el" href="classt8__scheme.html#a182d3891804730d35c64a96672669dc4" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">element_is_valid</a> </dd></dl>

</div>
</div>
<a id="a942750e63d9374d877d97ca6d4a5e028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942750e63d9374d877d97ca6d4a5e028">&#9670;&nbsp;</a></span>element_set_linear_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_set_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the entries of an allocated element according to a given linear id in a uniform refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">element</td><td>The element whose entries will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The linear id. id must fulfil 0 &lt;= id &lt; 'number of leaves in the uniform refinement' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a021be34142b77ebe52cf7c66c52a4b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021be34142b77ebe52cf7c66c52a4b63">&#9670;&nbsp;</a></span>element_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>debug_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>string_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a string with readable information about the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to translate into human-readable information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">debug_string</td><td>The string to fill. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string_size</td><td>The length of <em>debug_string</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa54cbd6c146c7b93ac4a8cf65efb7079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54cbd6c146c7b93ac4a8cf65efb7079">&#9670;&nbsp;</a></span>element_transform_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppose we have two trees that share a common face f. </p>
<p>Given an element e that is a subface of f in one of the trees and given the orientation of the tree connection, construct the face element of the respective tree neighbor that logically coincides with e but lies in the coordinate system of the neighbor tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respect to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientattion). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a79a0afde9fa6e9dda13e2bc33e403df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a0afde9fa6e9dda13e2bc33e403df2">&#9670;&nbsp;</a></span>elements_are_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::elements_are_family </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *&#160;</td>
          <td class="paramname"><em>fam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a given set of elements is a family or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fam</td><td>An array of as many elements as an element of class <em>tree_class</em> has siblings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if <em>fam</em> is not a family, nonzero if it is. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>level 0 elements do not form a family. </dd></dl>

</div>
</div>
<a id="a41e212bb5f95d9e07e65b54c911d2c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e212bb5f95d9e07e65b54c911d2c71">&#9670;&nbsp;</a></span>get_eclass_scheme_eclass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> t8_scheme::get_eclass_scheme_eclass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the eclass an eclass scheme is valid for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The valid tree class for the eclass scheme. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should return the input value as long as the eclass schemes are soreted correctly. In the future, the trees will access the schemes by a key and then this function will make more sense. </dd></dl>

</div>
</div>
<a id="a2b6c4d7de5838d2a7bf7f99c29467533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6c4d7de5838d2a7bf7f99c29467533">&#9670;&nbsp;</a></span>get_element_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t t8_scheme::get_element_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of any element of a given class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of an element of class <em>tree_class</em>. We provide a default implementation of this routine that should suffice for most use cases. </dd></dl>

</div>
</div>
<a id="a20feb307512cb9a2f9bc93fcf628cdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20feb307512cb9a2f9bc93fcf628cdfc">&#9670;&nbsp;</a></span>get_max_num_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::get_max_num_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the max number of children of an eclass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of tree the elements are part of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The max number of children of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a42ad9586fb7839910813418b6e5b22a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ad9586fb7839910813418b6e5b22a6">&#9670;&nbsp;</a></span>get_maxlevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::get_maxlevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum allowed level for any element of a given class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed level for elements of class <em>tree_class</em>. </dd></dl>

</div>
</div>
<a id="ad1d98eada4c87673a7c189a5b2a1cb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d98eada4c87673a7c189a5b2a1cb7e">&#9670;&nbsp;</a></span>get_num_eclass_schemes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t t8_scheme::get_num_eclass_schemes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of eclass schemes inside the scheme. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of eclass schemes. </dd></dl>

</div>
</div>
<a id="a5585e34278986190d562fa76c47d6470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5585e34278986190d562fa76c47d6470">&#9670;&nbsp;</a></span>refines_irregular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool t8_scheme::refines_irregular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if there is one element in the tree, that does not refine into 2^dim children. </p>
<p>Returns false otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is one element in the tree that does not refine into 2^dim children. </dd></dl>

</div>
</div>
<a id="ac981f585dda62a3a8613b04c096195eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac981f585dda62a3a8613b04c096195eb">&#9670;&nbsp;</a></span>set_to_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void t8_scheme::set_to_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td>
          <td class="paramname"><em>tree_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create the root element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_class</td><td>The eclass of the current tree. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">element</td><td>The element that is filled with the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d3a78bc332b7868397b835c8317ac47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3a78bc332b7868397b835c8317ac47">&#9670;&nbsp;</a></span>unref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int t8_scheme::unref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the reference count of the scheme. </p>
<p>If the reference count reaches zero, the scheme is deleted. </p><dl class="section return"><dt>Returns</dt><dd>The remaining reference count. If 0 the scheme was deleted. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/t8_schemes/<a class="el" href="t8__scheme_8hxx_source.html">t8_scheme.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
