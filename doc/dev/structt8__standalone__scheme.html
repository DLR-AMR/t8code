<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t8: t8_standalone_scheme&lt; TEclass &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">t8
   &#160;<span id="projectnumber">4.0.0-RC2.318-b667f</span>
   </div>
   <div id="projectbrief">t8code is a C library to manage a forest of adaptive                           space-trees of general element classes in parallel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">t8_standalone_scheme&lt; TEclass &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated implementation of the scheme interface based on cutting planes.  
 <a href="structt8__standalone__scheme.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="t8__standalone__implementation_8hxx_source.html">t8_standalone_implementation.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae157d4d85eb75c9e3fb250f36cde8b81"><td class="memItemLeft" align="right" valign="top"><a id="ae157d4d85eb75c9e3fb250f36cde8b81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ae157d4d85eb75c9e3fb250f36cde8b81">t8_standalone_scheme</a> () noexcept</td></tr>
<tr class="memdesc:ae157d4d85eb75c9e3fb250f36cde8b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ae157d4d85eb75c9e3fb250f36cde8b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa169d39d74dfaead352264c6f1115f17"><td class="memItemLeft" align="right" valign="top"><a id="aa169d39d74dfaead352264c6f1115f17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#aa169d39d74dfaead352264c6f1115f17">~t8_standalone_scheme</a> ()</td></tr>
<tr class="memdesc:aa169d39d74dfaead352264c6f1115f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for all default schemes. <br /></td></tr>
<tr class="separator:aa169d39d74dfaead352264c6f1115f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b98e106b97972ae00e1ba6aa4d7e2d"><td class="memItemLeft" align="right" valign="top"><a id="a55b98e106b97972ae00e1ba6aa4d7e2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a55b98e106b97972ae00e1ba6aa4d7e2d">t8_standalone_scheme</a> (<a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a55b98e106b97972ae00e1ba6aa4d7e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a55b98e106b97972ae00e1ba6aa4d7e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d9ae94cd497905d92a3c37ade9bffc"><td class="memItemLeft" align="right" valign="top"><a id="a50d9ae94cd497905d92a3c37ade9bffc"></a>
<a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a50d9ae94cd497905d92a3c37ade9bffc">operator=</a> (<a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a50d9ae94cd497905d92a3c37ade9bffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a50d9ae94cd497905d92a3c37ade9bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a6c2a36957a41475e60501f153386d"><td class="memItemLeft" align="right" valign="top"><a id="ae3a6c2a36957a41475e60501f153386d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ae3a6c2a36957a41475e60501f153386d">t8_standalone_scheme</a> (const <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a> &amp;other)</td></tr>
<tr class="memdesc:ae3a6c2a36957a41475e60501f153386d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ae3a6c2a36957a41475e60501f153386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66a00519cf78431bd71a511552d3128"><td class="memItemLeft" align="right" valign="top"><a id="aa66a00519cf78431bd71a511552d3128"></a>
<a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#aa66a00519cf78431bd71a511552d3128">operator=</a> (const <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a> &amp;other)</td></tr>
<tr class="memdesc:aa66a00519cf78431bd71a511552d3128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:aa66a00519cf78431bd71a511552d3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af303185962c4752994785883d9d993f8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#af303185962c4752994785883d9d993f8">get_eclass</a> (void) const</td></tr>
<tr class="memdesc:af303185962c4752994785883d9d993f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tree class of this scheme.  <a href="structt8__standalone__scheme.html#af303185962c4752994785883d9d993f8">More...</a><br /></td></tr>
<tr class="separator:af303185962c4752994785883d9d993f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b39465767ba3abbdc18049af817ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> (const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elems) const noexcept</td></tr>
<tr class="memdesc:a45b39465767ba3abbdc18049af817ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for an array of elements of a given class and initialize them.  <a href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">More...</a><br /></td></tr>
<tr class="separator:a45b39465767ba3abbdc18049af817ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7588e8060a9116116cebcc03870197d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a7588e8060a9116116cebcc03870197d9">element_destroy</a> (const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elems) const noexcept</td></tr>
<tr class="memdesc:a7588e8060a9116116cebcc03870197d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate an array of elements.  <a href="structt8__standalone__scheme.html#a7588e8060a9116116cebcc03870197d9">More...</a><br /></td></tr>
<tr class="separator:a7588e8060a9116116cebcc03870197d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b07163dec0f3fbc5b828b6598ff3a1d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a7b07163dec0f3fbc5b828b6598ff3a1d">element_MPI_Pack</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const elements, const unsigned int count, void *send_buffer, const int buffer_size, int *position, sc_MPI_Comm comm) const noexcept</td></tr>
<tr class="memdesc:a7b07163dec0f3fbc5b828b6598ff3a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack multiple elements into contiguous memory, so they can be sent via MPI.  <a href="structt8__standalone__scheme.html#a7b07163dec0f3fbc5b828b6598ff3a1d">More...</a><br /></td></tr>
<tr class="separator:a7b07163dec0f3fbc5b828b6598ff3a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9954f610322a9766c00e20df0bc0c4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a1f9954f610322a9766c00e20df0bc0c4">element_MPI_Pack_size</a> (const unsigned int count, sc_MPI_Comm comm, int *pack_size) const noexcept</td></tr>
<tr class="memdesc:a1f9954f610322a9766c00e20df0bc0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine an upper bound for the size of the packed message of <em>count</em> elements.  <a href="structt8__standalone__scheme.html#a1f9954f610322a9766c00e20df0bc0c4">More...</a><br /></td></tr>
<tr class="separator:a1f9954f610322a9766c00e20df0bc0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68452e2231d8b3281029cceb4132824b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a68452e2231d8b3281029cceb4132824b">element_MPI_Unpack</a> (void *recvbuf, const int buffer_size, int *position, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elements, const unsigned int count, sc_MPI_Comm comm) const noexcept</td></tr>
<tr class="memdesc:a68452e2231d8b3281029cceb4132824b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack multiple elements from contiguous memory that was received via MPI.  <a href="structt8__standalone__scheme.html#a68452e2231d8b3281029cceb4132824b">More...</a><br /></td></tr>
<tr class="separator:a68452e2231d8b3281029cceb4132824b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f63ec27654fb89fdfafcb02c885416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a16f63ec27654fb89fdfafcb02c885416">element_transform_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1,[[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2,[[maybe_unused]] const int orientation,[[maybe_unused]] const int sign,[[maybe_unused]] const int is_smaller_face) noexcept</td></tr>
<tr class="memdesc:a16f63ec27654fb89fdfafcb02c885416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we have two trees that share a common face f.  <a href="structt8__standalone__scheme.html#a16f63ec27654fb89fdfafcb02c885416">More...</a><br /></td></tr>
<tr class="separator:a16f63ec27654fb89fdfafcb02c885416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31dc674de1686b2cc690d92f7f83086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ae31dc674de1686b2cc690d92f7f83086">element_transform_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1,[[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2,[[maybe_unused]] const int orientation,[[maybe_unused]] const int sign,[[maybe_unused]] const int is_smaller_face) noexcept</td></tr>
<tr class="memdesc:ae31dc674de1686b2cc690d92f7f83086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> for lines.  <a href="structt8__standalone__scheme.html#ae31dc674de1686b2cc690d92f7f83086">More...</a><br /></td></tr>
<tr class="separator:ae31dc674de1686b2cc690d92f7f83086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5123e07eeed9f95914deb672883b5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ad5123e07eeed9f95914deb672883b5c4">element_transform_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2,[[maybe_unused]] int orientation, const int sign,[[maybe_unused]] const int is_smaller_face) noexcept</td></tr>
<tr class="memdesc:ad5123e07eeed9f95914deb672883b5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> for quads.  <a href="structt8__standalone__scheme.html#ad5123e07eeed9f95914deb672883b5c4">More...</a><br /></td></tr>
<tr class="separator:ad5123e07eeed9f95914deb672883b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a6d2d5f450c9dbfff59e1b65b79e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ad58a6d2d5f450c9dbfff59e1b65b79e1">element_transform_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1,[[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2,[[maybe_unused]] int orientation,[[maybe_unused]] const int sign,[[maybe_unused]] const int is_smaller_face) noexcept</td></tr>
<tr class="memdesc:ad58a6d2d5f450c9dbfff59e1b65b79e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> for triangles.  <a href="structt8__standalone__scheme.html#ad58a6d2d5f450c9dbfff59e1b65b79e1">More...</a><br /></td></tr>
<tr class="separator:ad58a6d2d5f450c9dbfff59e1b65b79e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6016f0d4a576740b267eb494791f4397"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a6016f0d4a576740b267eb494791f4397">get_element_size</a> (void) noexcept</td></tr>
<tr class="memdesc:a6016f0d4a576740b267eb494791f4397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of any element of a given class.  <a href="structt8__standalone__scheme.html#a6016f0d4a576740b267eb494791f4397">More...</a><br /></td></tr>
<tr class="separator:a6016f0d4a576740b267eb494791f4397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ff32174e03693c720ed49c9bd1c81"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a1d1ff32174e03693c720ed49c9bd1c81">refines_irregular</a> (void) noexcept</td></tr>
<tr class="memdesc:a1d1ff32174e03693c720ed49c9bd1c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if there is one element in the tree, that does not refine into 2^dim children.  <a href="structt8__standalone__scheme.html#a1d1ff32174e03693c720ed49c9bd1c81">More...</a><br /></td></tr>
<tr class="separator:a1d1ff32174e03693c720ed49c9bd1c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e60c011d267dcc856ff77e3c48765eb"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a0e60c011d267dcc856ff77e3c48765eb">get_maxlevel</a> (void) noexcept</td></tr>
<tr class="memdesc:a0e60c011d267dcc856ff77e3c48765eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowed level for any element of a given class.  <a href="structt8__standalone__scheme.html#a0e60c011d267dcc856ff77e3c48765eb">More...</a><br /></td></tr>
<tr class="separator:a0e60c011d267dcc856ff77e3c48765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdf58ff403924e798772b01d8f9eb8e"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a3fdf58ff403924e798772b01d8f9eb8e">element_get_num_corners</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a3fdf58ff403924e798772b01d8f9eb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of corners of a given element.  <a href="structt8__standalone__scheme.html#a3fdf58ff403924e798772b01d8f9eb8e">More...</a><br /></td></tr>
<tr class="separator:a3fdf58ff403924e798772b01d8f9eb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89073b5dfa648aa6083ffa86cfc51949"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a89073b5dfa648aa6083ffa86cfc51949">element_get_num_faces</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a89073b5dfa648aa6083ffa86cfc51949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of faces of a given element.  <a href="structt8__standalone__scheme.html#a89073b5dfa648aa6083ffa86cfc51949">More...</a><br /></td></tr>
<tr class="separator:a89073b5dfa648aa6083ffa86cfc51949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751ea010b320ce07de31bf471cd6d688"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a751ea010b320ce07de31bf471cd6d688">element_get_max_num_faces</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a751ea010b320ce07de31bf471cd6d688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of faces of a given element and all of its descendants.  <a href="structt8__standalone__scheme.html#a751ea010b320ce07de31bf471cd6d688">More...</a><br /></td></tr>
<tr class="separator:a751ea010b320ce07de31bf471cd6d688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aebbdf67fedfa88262acecf462b761c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a6aebbdf67fedfa88262acecf462b761c">element_get_shape</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a6aebbdf67fedfa88262acecf462b761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape of an allocated element according its type.  <a href="structt8__standalone__scheme.html#a6aebbdf67fedfa88262acecf462b761c">More...</a><br /></td></tr>
<tr class="separator:a6aebbdf67fedfa88262acecf462b761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f294bb211547673fe50757291c3ba90"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a7f294bb211547673fe50757291c3ba90">element_get_face_corner</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int face, const int corner) noexcept</td></tr>
<tr class="memdesc:a7f294bb211547673fe50757291c3ba90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corner number of an element's face corner.  <a href="structt8__standalone__scheme.html#a7f294bb211547673fe50757291c3ba90">More...</a><br /></td></tr>
<tr class="separator:a7f294bb211547673fe50757291c3ba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848e6b950d9b49c13131c954ff7fc37c"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a848e6b950d9b49c13131c954ff7fc37c">element_get_corner_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, const int corner, const int face) noexcept</td></tr>
<tr class="memdesc:a848e6b950d9b49c13131c954ff7fc37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the face numbers of the faces sharing an element's corner.  <a href="structt8__standalone__scheme.html#a848e6b950d9b49c13131c954ff7fc37c">More...</a><br /></td></tr>
<tr class="separator:a848e6b950d9b49c13131c954ff7fc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc20e3925da58a71a6e919a9f9b7eee"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a6cc20e3925da58a71a6e919a9f9b7eee">element_get_face_shape</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, [[maybe_unused]] const int face) noexcept</td></tr>
<tr class="memdesc:a6cc20e3925da58a71a6e919a9f9b7eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shape of the face of an element.  <a href="structt8__standalone__scheme.html#a6cc20e3925da58a71a6e919a9f9b7eee">More...</a><br /></td></tr>
<tr class="separator:a6cc20e3925da58a71a6e919a9f9b7eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c91fe980ee938ba2719d5bcd7e8e470"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a9c91fe980ee938ba2719d5bcd7e8e470">element_copy</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *source, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *dest) noexcept</td></tr>
<tr class="memdesc:a9c91fe980ee938ba2719d5bcd7e8e470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all entries of <b>source</b> to <b>dest</b>.  <a href="structt8__standalone__scheme.html#a9c91fe980ee938ba2719d5bcd7e8e470">More...</a><br /></td></tr>
<tr class="separator:a9c91fe980ee938ba2719d5bcd7e8e470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1a7d7da60741b0bfd36e28c2ec6feb"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#abc1a7d7da60741b0bfd36e28c2ec6feb">element_is_equal</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) noexcept</td></tr>
<tr class="memdesc:abc1a7d7da60741b0bfd36e28c2ec6feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are equal.  <a href="structt8__standalone__scheme.html#abc1a7d7da60741b0bfd36e28c2ec6feb">More...</a><br /></td></tr>
<tr class="separator:abc1a7d7da60741b0bfd36e28c2ec6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4972f1d813518ef3798b2ba712b989"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#acb4972f1d813518ef3798b2ba712b989">element_get_level</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:acb4972f1d813518ef3798b2ba712b989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of a particular element.  <a href="structt8__standalone__scheme.html#acb4972f1d813518ef3798b2ba712b989">More...</a><br /></td></tr>
<tr class="separator:acb4972f1d813518ef3798b2ba712b989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c8a868274d577c587b188e7179d1e5"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a39c8a868274d577c587b188e7179d1e5">set_to_root</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a39c8a868274d577c587b188e7179d1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create the root element  <a href="structt8__standalone__scheme.html#a39c8a868274d577c587b188e7179d1e5">More...</a><br /></td></tr>
<tr class="separator:a39c8a868274d577c587b188e7179d1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c46a32ff3fdd79119608d0607e316e"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a32c46a32ff3fdd79119608d0607e316e">element_get_parent</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *parent) noexcept</td></tr>
<tr class="memdesc:a32c46a32ff3fdd79119608d0607e316e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the parent of a given element <b>elem</b> and store it in <b>parent</b>.  <a href="structt8__standalone__scheme.html#a32c46a32ff3fdd79119608d0607e316e">More...</a><br /></td></tr>
<tr class="separator:a32c46a32ff3fdd79119608d0607e316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9666e41ba08e941e0e61ace0efca18bd"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a9666e41ba08e941e0e61ace0efca18bd">element_get_num_siblings</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a9666e41ba08e941e0e61ace0efca18bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of siblings of an element.  <a href="structt8__standalone__scheme.html#a9666e41ba08e941e0e61ace0efca18bd">More...</a><br /></td></tr>
<tr class="separator:a9666e41ba08e941e0e61ace0efca18bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0595cdfdcf8c3662b192782f58233750"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a0595cdfdcf8c3662b192782f58233750">element_get_sibling</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, [[maybe_unused]] const int sibid, [[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *sibling) noexcept</td></tr>
<tr class="memdesc:a0595cdfdcf8c3662b192782f58233750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a specific sibling of a given element <b>elem</b> and store it in <b>sibling</b>.  <a href="structt8__standalone__scheme.html#a0595cdfdcf8c3662b192782f58233750">More...</a><br /></td></tr>
<tr class="separator:a0595cdfdcf8c3662b192782f58233750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891571dba96dbd5cee998124ee9e2dc4"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a891571dba96dbd5cee998124ee9e2dc4">element_get_child</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int childid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *child) noexcept</td></tr>
<tr class="memdesc:a891571dba96dbd5cee998124ee9e2dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the child element of a given number.  <a href="structt8__standalone__scheme.html#a891571dba96dbd5cee998124ee9e2dc4">More...</a><br /></td></tr>
<tr class="separator:a891571dba96dbd5cee998124ee9e2dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfc3478b4dd165d0a8278a65e208f35"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a8dfc3478b4dd165d0a8278a65e208f35">element_get_num_children</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a8dfc3478b4dd165d0a8278a65e208f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element when it is refined.  <a href="structt8__standalone__scheme.html#a8dfc3478b4dd165d0a8278a65e208f35">More...</a><br /></td></tr>
<tr class="separator:a8dfc3478b4dd165d0a8278a65e208f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacff8e813905edccbb9c54e5b0665874"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#aacff8e813905edccbb9c54e5b0665874">get_max_num_children</a> () noexcept</td></tr>
<tr class="memdesc:aacff8e813905edccbb9c54e5b0665874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the max number of children of an eclass.  <a href="structt8__standalone__scheme.html#aacff8e813905edccbb9c54e5b0665874">More...</a><br /></td></tr>
<tr class="separator:aacff8e813905edccbb9c54e5b0665874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421e00640ef800432aadc5058358eaa3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a421e00640ef800432aadc5058358eaa3">element_is_refinable</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a421e00640ef800432aadc5058358eaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if an element is refinable.  <a href="structt8__standalone__scheme.html#a421e00640ef800432aadc5058358eaa3">More...</a><br /></td></tr>
<tr class="separator:a421e00640ef800432aadc5058358eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c91eec4989ebdd3fd23caacf69c70d"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a52c91eec4989ebdd3fd23caacf69c70d">element_get_children</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *c[]) noexcept</td></tr>
<tr class="memdesc:a52c91eec4989ebdd3fd23caacf69c70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct all children of a given element.  <a href="structt8__standalone__scheme.html#a52c91eec4989ebdd3fd23caacf69c70d">More...</a><br /></td></tr>
<tr class="separator:a52c91eec4989ebdd3fd23caacf69c70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4e092fa6d367af64787bbe5970b112"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a8e4e092fa6d367af64787bbe5970b112">element_get_child_id</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a8e4e092fa6d367af64787bbe5970b112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the child id of an element.  <a href="structt8__standalone__scheme.html#a8e4e092fa6d367af64787bbe5970b112">More...</a><br /></td></tr>
<tr class="separator:a8e4e092fa6d367af64787bbe5970b112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc57fb7df4e8cead597913c53686af9"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a7cc57fb7df4e8cead597913c53686af9">element_get_ancestor_id</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:a7cc57fb7df4e8cead597913c53686af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ancestor id of an element, that is the child id at a given level.  <a href="structt8__standalone__scheme.html#a7cc57fb7df4e8cead597913c53686af9">More...</a><br /></td></tr>
<tr class="separator:a7cc57fb7df4e8cead597913c53686af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd65898bb1783d0d5d986dc4cee8e12"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a3fd65898bb1783d0d5d986dc4cee8e12">elements_are_family</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *fam) noexcept</td></tr>
<tr class="memdesc:a3fd65898bb1783d0d5d986dc4cee8e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given set of elements is a family or not.  <a href="structt8__standalone__scheme.html#a3fd65898bb1783d0d5d986dc4cee8e12">More...</a><br /></td></tr>
<tr class="separator:a3fd65898bb1783d0d5d986dc4cee8e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e13b18f053a080d7527090035588703"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a1e13b18f053a080d7527090035588703">element_get_nca</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *nca) noexcept</td></tr>
<tr class="memdesc:a1e13b18f053a080d7527090035588703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nearest common ancestor of two elements.  <a href="structt8__standalone__scheme.html#a1e13b18f053a080d7527090035588703">More...</a><br /></td></tr>
<tr class="separator:a1e13b18f053a080d7527090035588703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7dd1cdde1132311f1c1300aa729ed4"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a5f7dd1cdde1132311f1c1300aa729ed4">element_get_first_descendant</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:a5f7dd1cdde1132311f1c1300aa729ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first descendant of a given element.  <a href="structt8__standalone__scheme.html#a5f7dd1cdde1132311f1c1300aa729ed4">More...</a><br /></td></tr>
<tr class="separator:a5f7dd1cdde1132311f1c1300aa729ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd550eeb3d3717d65c7723c1cb0dac60"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#acd550eeb3d3717d65c7723c1cb0dac60">element_get_last_descendant</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:acd550eeb3d3717d65c7723c1cb0dac60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the last descendant of a given element.  <a href="structt8__standalone__scheme.html#acd550eeb3d3717d65c7723c1cb0dac60">More...</a><br /></td></tr>
<tr class="separator:acd550eeb3d3717d65c7723c1cb0dac60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4928a7b5adc63e8b786994aef0f904c5"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a4928a7b5adc63e8b786994aef0f904c5">element_get_num_face_children</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, [[maybe_unused]] const int face) noexcept</td></tr>
<tr class="memdesc:a4928a7b5adc63e8b786994aef0f904c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element's face when the element is refined.  <a href="structt8__standalone__scheme.html#a4928a7b5adc63e8b786994aef0f904c5">More...</a><br /></td></tr>
<tr class="separator:a4928a7b5adc63e8b786994aef0f904c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d98ccc5a2cf600b35049ba441dd58b6"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a9d98ccc5a2cf600b35049ba441dd58b6">element_get_children_at_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *children[], const int num_children, [[maybe_unused]] int *child_indices) noexcept</td></tr>
<tr class="memdesc:a9d98ccc5a2cf600b35049ba441dd58b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of the element, compute all children of the element that touch the face.  <a href="structt8__standalone__scheme.html#a9d98ccc5a2cf600b35049ba441dd58b6">More...</a><br /></td></tr>
<tr class="separator:a9d98ccc5a2cf600b35049ba441dd58b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da3b3d9bf2a9eab88ddc795c264afc"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ac6da3b3d9bf2a9eab88ddc795c264afc">element_face_get_child_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, [[maybe_unused]] const int face_child) noexcept</td></tr>
<tr class="memdesc:ac6da3b3d9bf2a9eab88ddc795c264afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face.  <a href="structt8__standalone__scheme.html#ac6da3b3d9bf2a9eab88ddc795c264afc">More...</a><br /></td></tr>
<tr class="separator:ac6da3b3d9bf2a9eab88ddc795c264afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef28d8a2feca33ef22c32969a46b864e"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#aef28d8a2feca33ef22c32969a46b864e">element_face_get_parent_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) noexcept</td></tr>
<tr class="memdesc:aef28d8a2feca33ef22c32969a46b864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element return the face number of the parent of the element that matches the element's face.  <a href="structt8__standalone__scheme.html#aef28d8a2feca33ef22c32969a46b864e">More...</a><br /></td></tr>
<tr class="separator:aef28d8a2feca33ef22c32969a46b864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb113ca47b3ffc8e5ecb65000a943f1"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a0eb113ca47b3ffc8e5ecb65000a943f1">element_get_first_descendant_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *first_desc, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:a0eb113ca47b3ffc8e5ecb65000a943f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the first descendant of an element at a given level that touches a given face.  <a href="structt8__standalone__scheme.html#a0eb113ca47b3ffc8e5ecb65000a943f1">More...</a><br /></td></tr>
<tr class="separator:a0eb113ca47b3ffc8e5ecb65000a943f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528dac6e73c1c9f5dc262325f54155ad"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a528dac6e73c1c9f5dc262325f54155ad">element_get_last_descendant_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *last_desc, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:a528dac6e73c1c9f5dc262325f54155ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the last descendant of an element at a given level that touches a given face.  <a href="structt8__standalone__scheme.html#a528dac6e73c1c9f5dc262325f54155ad">More...</a><br /></td></tr>
<tr class="separator:a528dac6e73c1c9f5dc262325f54155ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a3ebd2ceea871448f111a8ee33ed6f"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#af4a3ebd2ceea871448f111a8ee33ed6f">element_is_root_boundary</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) noexcept</td></tr>
<tr class="memdesc:af4a3ebd2ceea871448f111a8ee33ed6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether a given element shares a given face with its root tree.  <a href="structt8__standalone__scheme.html#af4a3ebd2ceea871448f111a8ee33ed6f">More...</a><br /></td></tr>
<tr class="separator:af4a3ebd2ceea871448f111a8ee33ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f14671a6d813d14a02acf8a84485f0"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a66f14671a6d813d14a02acf8a84485f0">element_get_tree_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face) noexcept</td></tr>
<tr class="memdesc:a66f14671a6d813d14a02acf8a84485f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of this element.  <a href="structt8__standalone__scheme.html#a66f14671a6d813d14a02acf8a84485f0">More...</a><br /></td></tr>
<tr class="separator:a66f14671a6d813d14a02acf8a84485f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb78136ca2da2343631641677d99e3d"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#aadb78136ca2da2343631641677d99e3d">element_get_face_neighbor_inside</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *neigh, const int face, int *neigh_face) noexcept</td></tr>
<tr class="memdesc:aadb78136ca2da2343631641677d99e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the face neighbor of a given element if this face neighbor is inside the root tree.  <a href="structt8__standalone__scheme.html#aadb78136ca2da2343631641677d99e3d">More...</a><br /></td></tr>
<tr class="separator:aadb78136ca2da2343631641677d99e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53d296eee52281323c84a4fdde63773"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, [[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, [[maybe_unused]] const int orientation, [[maybe_unused]] const int sign, [[maybe_unused]] const int is_smaller_face) noexcept</td></tr>
<tr class="memdesc:aa53d296eee52281323c84a4fdde63773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we have two trees that share a common face f.  <a href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">More...</a><br /></td></tr>
<tr class="separator:aa53d296eee52281323c84a4fdde63773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b8a30a9d33a1e566977a4e0fde153b"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a67b8a30a9d33a1e566977a4e0fde153b">element_extrude_face</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *face, [[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, [[maybe_unused]] const int root_face, [[maybe_unused]] const <a class="el" href="classt8__scheme.html">t8_scheme</a> *scheme) noexcept</td></tr>
<tr class="memdesc:a67b8a30a9d33a1e566977a4e0fde153b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face.  <a href="structt8__standalone__scheme.html#a67b8a30a9d33a1e566977a4e0fde153b">More...</a><br /></td></tr>
<tr class="separator:a67b8a30a9d33a1e566977a4e0fde153b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a645fe5af8716371a983c48020abc76"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a0a645fe5af8716371a983c48020abc76">element_get_boundary_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int face, [[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *boundary, [[maybe_unused]] const <a class="el" href="classt8__scheme.html">t8_scheme</a> *scheme) noexcept</td></tr>
<tr class="memdesc:a0a645fe5af8716371a983c48020abc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the boundary element at a specific face.  <a href="structt8__standalone__scheme.html#a0a645fe5af8716371a983c48020abc76">More...</a><br /></td></tr>
<tr class="separator:a0a645fe5af8716371a983c48020abc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7988c76b1416521f211835429c39e9"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a9b7988c76b1416521f211835429c39e9">element_set_linear_id</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const t8_element_level level, <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> id) noexcept</td></tr>
<tr class="memdesc:a9b7988c76b1416521f211835429c39e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the entries of an allocated element according to a given linear id in a uniform refinement.  <a href="structt8__standalone__scheme.html#a9b7988c76b1416521f211835429c39e9">More...</a><br /></td></tr>
<tr class="separator:a9b7988c76b1416521f211835429c39e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c2acf05509a07b1dcd9fe6caf3314f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#ad8c2acf05509a07b1dcd9fe6caf3314f">element_get_linear_id</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:ad8c2acf05509a07b1dcd9fe6caf3314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear id of a given element in a hypothetical uniform refinement of a given level.  <a href="structt8__standalone__scheme.html#ad8c2acf05509a07b1dcd9fe6caf3314f">More...</a><br /></td></tr>
<tr class="separator:ad8c2acf05509a07b1dcd9fe6caf3314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a010bddb36aeaada9b50b45afc6b9f"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a14a010bddb36aeaada9b50b45afc6b9f">element_construct_successor</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) noexcept</td></tr>
<tr class="memdesc:a14a010bddb36aeaada9b50b45afc6b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the successor in a uniform refinement of a given element.  <a href="structt8__standalone__scheme.html#a14a010bddb36aeaada9b50b45afc6b9f">More...</a><br /></td></tr>
<tr class="separator:a14a010bddb36aeaada9b50b45afc6b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7320f1426863cb91ea3b001efeda560c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a7320f1426863cb91ea3b001efeda560c">element_count_leaves</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:a7320f1426863cb91ea3b001efeda560c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level an element would produce.  <a href="structt8__standalone__scheme.html#a7320f1426863cb91ea3b001efeda560c">More...</a><br /></td></tr>
<tr class="separator:a7320f1426863cb91ea3b001efeda560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315c278e3eb25fec9156b3eebd420b29"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a315c278e3eb25fec9156b3eebd420b29">count_leaves_from_root</a> (const t8_element_level level) noexcept</td></tr>
<tr class="memdesc:a315c278e3eb25fec9156b3eebd420b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level the root element will produce.  <a href="structt8__standalone__scheme.html#a315c278e3eb25fec9156b3eebd420b29">More...</a><br /></td></tr>
<tr class="separator:a315c278e3eb25fec9156b3eebd420b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a55b73f5500bdf8fc20b27d457a40"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a465a55b73f5500bdf8fc20b27d457a40">element_compare</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) noexcept</td></tr>
<tr class="memdesc:a465a55b73f5500bdf8fc20b27d457a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two elements.  <a href="structt8__standalone__scheme.html#a465a55b73f5500bdf8fc20b27d457a40">More...</a><br /></td></tr>
<tr class="separator:a465a55b73f5500bdf8fc20b27d457a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0898db02cc70df0bd29b6b0c6aaebf02"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a0898db02cc70df0bd29b6b0c6aaebf02">element_get_vertex_reference_coords</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int vertex, double coords[]) noexcept</td></tr>
<tr class="memdesc:a0898db02cc70df0bd29b6b0c6aaebf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension).  <a href="structt8__standalone__scheme.html#a0898db02cc70df0bd29b6b0c6aaebf02">More...</a><br /></td></tr>
<tr class="separator:a0898db02cc70df0bd29b6b0c6aaebf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454e7106d70aa2a85008ed955a99b30d"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a454e7106d70aa2a85008ed955a99b30d">element_get_reference_coords</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const double *ref_coords, const size_t num_coords, double *out_coords) noexcept</td></tr>
<tr class="memdesc:a454e7106d70aa2a85008ed955a99b30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point in the reference space of an element to a point in the reference space of the tree.  <a href="structt8__standalone__scheme.html#a454e7106d70aa2a85008ed955a99b30d">More...</a><br /></td></tr>
<tr class="separator:a454e7106d70aa2a85008ed955a99b30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a943444f20744f36890004c48b44723"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> ([[maybe_unused]] const int length, [[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elems) noexcept</td></tr>
<tr class="memdesc:a0a943444f20744f36890004c48b44723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of allocated elements.  <a href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">More...</a><br /></td></tr>
<tr class="separator:a0a943444f20744f36890004c48b44723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904fbb7cc789eaa641f5ceca6350803b"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a904fbb7cc789eaa641f5ceca6350803b">element_deinit</a> ([[maybe_unused]] const int length, [[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elems) noexcept</td></tr>
<tr class="memdesc:a904fbb7cc789eaa641f5ceca6350803b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize an array of allocated elements.  <a href="structt8__standalone__scheme.html#a904fbb7cc789eaa641f5ceca6350803b">More...</a><br /></td></tr>
<tr class="separator:a904fbb7cc789eaa641f5ceca6350803b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdff14dbf8ea45c7e9dadd22d832283"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a4bdff14dbf8ea45c7e9dadd22d832283">element_is_valid</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a4bdff14dbf8ea45c7e9dadd22d832283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it.  <a href="structt8__standalone__scheme.html#a4bdff14dbf8ea45c7e9dadd22d832283">More...</a><br /></td></tr>
<tr class="separator:a4bdff14dbf8ea45c7e9dadd22d832283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001f63a3f349649a5343e5eaa08d79a8"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a001f63a3f349649a5343e5eaa08d79a8">element_debug_print</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) noexcept</td></tr>
<tr class="memdesc:a001f63a3f349649a5343e5eaa08d79a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a given element.  <a href="structt8__standalone__scheme.html#a001f63a3f349649a5343e5eaa08d79a8">More...</a><br /></td></tr>
<tr class="separator:a001f63a3f349649a5343e5eaa08d79a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0df60159857ecbf95a918b621a157"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a41f0df60159857ecbf95a918b621a157">element_to_string</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, char *debug_string, const int string_size) noexcept</td></tr>
<tr class="memdesc:a41f0df60159857ecbf95a918b621a157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a string with readable information about the element.  <a href="structt8__standalone__scheme.html#a41f0df60159857ecbf95a918b621a157">More...</a><br /></td></tr>
<tr class="separator:a41f0df60159857ecbf95a918b621a157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4db9c6df544c02cf689c85a051ab73cf"><td class="memItemLeft" align="right" valign="top"><a id="a4db9c6df544c02cf689c85a051ab73cf"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a4db9c6df544c02cf689c85a051ab73cf">element_size</a></td></tr>
<tr class="memdesc:a4db9c6df544c02cf689c85a051ab73cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size in bytes of an element of class <em>eclass</em>. <br /></td></tr>
<tr class="separator:a4db9c6df544c02cf689c85a051ab73cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c6a09ce6f750cc322f8134b846829e"><td class="memItemLeft" align="right" valign="top"><a id="a92c6a09ce6f750cc322f8134b846829e"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__standalone__scheme.html#a92c6a09ce6f750cc322f8134b846829e">scheme_context</a></td></tr>
<tr class="memdesc:a92c6a09ce6f750cc322f8134b846829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymous implementation context. <br /></td></tr>
<tr class="separator:a92c6a09ce6f750cc322f8134b846829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;t8_eclass TEclass&gt;<br />
struct t8_standalone_scheme&lt; TEclass &gt;</h3>

<p>A templated implementation of the scheme interface based on cutting planes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a315c278e3eb25fec9156b3eebd420b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315c278e3eb25fec9156b3eebd420b29">&#9670;&nbsp;</a></span>count_leaves_from_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::count_leaves_from_root </td>
          <td>(</td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level the root element will produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="t8__scheme_8h.html#acce8f7fe7d7665529976e43cf71e8d48">t8_element_count_leaves</a> if the input element is the root (level 0) element.</dd></dl>
<p>This is a convenience function, and can be implemented via <a class="el" href="t8__scheme_8h.html#acce8f7fe7d7665529976e43cf71e8d48">t8_element_count_leaves</a>. </p>

</div>
</div>
<a id="a465a55b73f5500bdf8fc20b27d457a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465a55b73f5500bdf8fc20b27d457a40">&#9670;&nbsp;</a></span>element_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative if elem1 &lt; elem2, zero if elem1 equals elem2 and positive if elem1 &gt; elem2. If elem2 is a copy of elem1 then the elements are equal. </dd></dl>

</div>
</div>
<a id="a14a010bddb36aeaada9b50b45afc6b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a010bddb36aeaada9b50b45afc6b9f">&#9670;&nbsp;</a></span>element_construct_successor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_construct_successor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the successor in a uniform refinement of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The element whose successor should be constructed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>The element whose entries will be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c91fe980ee938ba2719d5bcd7e8e470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c91fe980ee938ba2719d5bcd7e8e470">&#9670;&nbsp;</a></span>element_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all entries of <b>source</b> to <b>dest</b>. </p>
<p><b>dest</b> must be an existing element. No memory is allocated by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The element whose entries will be copied to <b>dest</b>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>This element's entries will be overwrite with the entries of <b>source</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>source</em> and <em>dest</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a7320f1426863cb91ea3b001efeda560c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7320f1426863cb91ea3b001efeda560c">&#9670;&nbsp;</a></span>element_count_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a> <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_count_leaves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many leaf descendants of a given uniform level an element would produce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Suppose <em>elem</em> is uniformly refined up to level <em>level</em>. The return value is the resulting number of elements (of the given level). If <em>level</em> &lt; t8_element_level(t), the return value should be 0.</dd></dl>
<p>Example: If <em>elem</em> is a line element that refines into 2 line elements on each level, then the return value is max(0, 2^{<em>level</em> - level(<em>t</em>)}). Thus, if <em>elem's</em> level is 0, and <em>level</em> = 3, the return value is 2^3 = 8. </p>

</div>
</div>
<a id="a001f63a3f349649a5343e5eaa08d79a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001f63a3f349649a5343e5eaa08d79a8">&#9670;&nbsp;</a></span>element_debug_print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_debug_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a given element. </p>
<p>For a example for a triangle print the coordinates and the level of the triangle. This function is only available in the debugging configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to print </td></tr>
  </table>
  </dd>
</dl>
<p>for (int e = 0; e &lt; T8_ELEMENT_NUM_EQUATIONS[TEclass]; e++) { t8_debugf ("t_%i: %i \n", e, el-&gt;type[e]); } ToDo-Type</p>

</div>
</div>
<a id="a904fbb7cc789eaa641f5ceca6350803b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904fbb7cc789eaa641f5ceca6350803b">&#9670;&nbsp;</a></span>element_deinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_deinit </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize an array of allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be deinitialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <em>length</em> many allocated and initialized elements, on output an array of <em>length</em> many allocated, but not initialized elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Call this function if you called element_init on the element pointers. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723" title="Initialize an array of allocated elements.">element_init</a> </dd></dl>

</div>
</div>
<a id="a7588e8060a9116116cebcc03870197d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7588e8060a9116116cebcc03870197d9">&#9670;&nbsp;</a></span>element_destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_destroy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate an array of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <b>length</b> many allocated element pointers. On output all these pointers will be freed. <b>elems</b> itself will not be freed by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67b8a30a9d33a1e566977a4e0fde153b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b8a30a9d33a1e566977a4e0fde153b">&#9670;&nbsp;</a></span>element_extrude_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_extrude_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>root_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="classt8__scheme.html">t8_scheme</a> *&#160;</td>
          <td class="paramname"><em>scheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>An allocated element. The entries will be filled with the data of the element that has <em>face</em> as a face and lies within the root tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_face</td><td>The index of the face of the root tree in which <em>face</em> lies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scheme</td><td>The scheme collection with a scheme for the eclass of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of <em>elem</em> that coincides with <em>face</em>. </dd></dl>

</div>
</div>
<a id="ac6da3b3d9bf2a9eab88ddc795c264afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da3b3d9bf2a9eab88ddc795c264afc">&#9670;&nbsp;</a></span>element_face_get_child_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_face_get_child_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>face_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face. </p>
<pre class="fragment">  x ---- x   x      x           x ---- x
  |      |   |      |           |   |  | &lt;-- f
  |      |   |      x           |   x--x
  |      |   |                  |      |
  x ---- x   x                  x ---- x
  elem    face  face_child    Returns the face number f
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_child</td><td>A number 0 &lt;= <em>face_child</em> &lt; num_face_children, specifying a child of <em>elem</em> that shares a face with <em>face</em>. These children are counted in linear order. This coincides with the order of children from a call to <a class="el" href="structt8__standalone__scheme.html#a9d98ccc5a2cf600b35049ba441dd58b6">element_get_children_at_face</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of a child of <em>elem</em> that coincides with <em>face_child</em>. </dd></dl>

</div>
</div>
<a id="aef28d8a2feca33ef22c32969a46b864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef28d8a2feca33ef22c32969a46b864e">&#9670;&nbsp;</a></span>element_face_get_parent_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_face_get_parent_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a face of an element return the face number of the parent of the element that matches the element's face. </p>
<p>Or return -1 if no face of the parent matches the face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>face</em> of <em>elem</em> is also a face of <em>elem's</em> parent, the face number of this face. Otherwise -1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For the root element this function always returns <em>face</em>. </dd></dl>

</div>
</div>
<a id="a7cc57fb7df4e8cead597913c53686af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc57fb7df4e8cead597913c53686af9">&#9670;&nbsp;</a></span>element_get_ancestor_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_ancestor_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the ancestor id of an element, that is the child id at a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. Must satisfy <em>level</em> &lt; elem.level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child_id of <em>elem</em> in regard to its <em>level</em> ancestor. </dd></dl>

</div>
</div>
<a id="a0a645fe5af8716371a983c48020abc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a645fe5af8716371a983c48020abc76">&#9670;&nbsp;</a></span>element_get_boundary_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_boundary_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="classt8__scheme.html">t8_scheme</a> *&#160;</td>
          <td class="paramname"><em>scheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the boundary element at a specific face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face of which to construct the boundary element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundary</td><td>An allocated element of dimension of <em>element</em> minus 1. The entries will be filled with the entries of the face of <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scheme</td><td>The scheme containing an eclass scheme for the boundary face. If <em>elem</em> is of class T8_ECLASS_VERTEX, then <em>boundary</em> must be NULL and will not be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a891571dba96dbd5cee998124ee9e2dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891571dba96dbd5cee998124ee9e2dc4">&#9670;&nbsp;</a></span>element_get_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>childid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the child element of a given number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childid</td><td>The number of the child to construct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child</td><td>The storage for this element must exist and match the element class of the child. For a pyramid, for example, it may be either a tetrahedron or a pyramid depending on <em>childid</em>. This can be checked by <em>t8_element_child_eclass</em>. On output, a valid element. It is valid to call this function with elem = child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>t8_element_child_eclass </dd></dl>

</div>
</div>
<a id="a8e4e092fa6d367af64787bbe5970b112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4e092fa6d367af64787bbe5970b112">&#9670;&nbsp;</a></span>element_get_child_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_child_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the child id of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id of elem. </dd></dl>

</div>
</div>
<a id="a52c91eec4989ebdd3fd23caacf69c70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c91eec4989ebdd3fd23caacf69c70d">&#9670;&nbsp;</a></span>element_get_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct all children of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the output array <em>c</em> must match the number of children. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The storage for these <em>length</em> elements must exist and match the element class in the children's ordering. On output, all children are valid. It is valid to call this function with elem = c[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>t8_element_num_children </dd>
<dd>
t8_element_child_eclass </dd></dl>

</div>
</div>
<a id="a9d98ccc5a2cf600b35049ba441dd58b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d98ccc5a2cf600b35049ba441dd58b6">&#9670;&nbsp;</a></span>element_get_children_at_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_children_at_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] int *&#160;</td>
          <td class="paramname"><em>child_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an element and a face of the element, compute all children of the element that touch the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">children</td><td>Allocated elements, in which the children of <em>elem</em> that share a face with <em>face</em> are stored. They will be stored in order of their linear id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_children</td><td>The number of elements in <em>children</em>. Must match the number of children that touch <em>face</em>. <a class="el" href="structt8__standalone__scheme.html#a4928a7b5adc63e8b786994aef0f904c5">element_get_num_face_children</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child_indices</td><td>If not NULL, an array of num_children integers must be given, on output its i-th entry is the child_id of the i-th face_child. It is valid to call this function with elem = children[0]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a848e6b950d9b49c13131c954ff7fc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848e6b950d9b49c13131c954ff7fc37c">&#9670;&nbsp;</a></span>element_get_corner_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_corner_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the face numbers of the faces sharing an element's corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 face 2 Thus for corner = 1 the output is: face=0 : 2, face=1: 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>corner</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the <em>face-th</em> face at <em>corner</em>. </dd></dl>

</div>
</div>
<a id="a7f294bb211547673fe50757291c3ba90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f294bb211547673fe50757291c3ba90">&#9670;&nbsp;</a></span>element_get_face_corner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_face_corner </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the corner number of an element's face corner. </p>
<p>Example quad: 2 x &mdash; x 3 | | | | face 1 0 x &mdash; x 1 Thus for face = 1 the output is: corner=0 : 1, corner=1: 3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face 0 &lt;= <em>corner</em> &lt; num_face_corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner number of the <em>corner-th</em> vertex of <em>face</em>.</dd></dl>
<p>The order in which the corners must be given is determined by the eclass of <em>element:</em> LINE/QUAD/TRIANGLE: No specific order. HEX : In Z-order of the face starting with the lowest corner number. TET : Starting with the lowest corner number counterclockwise as seen from 'outside' of the element. </p>

</div>
</div>
<a id="aadb78136ca2da2343631641677d99e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb78136ca2da2343631641677d99e3d">&#9670;&nbsp;</a></span>element_get_face_neighbor_inside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_face_neighbor_inside </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>neigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neigh_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the face neighbor of a given element if this face neighbor is inside the root tree. </p>
<p>Return 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh</td><td>If the face neighbor of <em>elem</em> along <em>face</em> is inside the root tree, this element's data is filled with the data of the face neighbor. Otherwise the data can be modified arbitrarily. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The number of the face along which the neighbor should be constructed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_face</td><td>The number of <em>face</em> as viewed from <em>neigh</em>. An arbitrary value, if the neighbor is not inside the root tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>neigh</em> is inside the root tree. False if not. In this case <em>neigh's</em> data can be arbitrary on output. </dd></dl>
<p>Adapt coordinates</p>
<p>check inside root</p>

</div>
</div>
<a id="a6cc20e3925da58a71a6e919a9f9b7eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc20e3925da58a71a6e919a9f9b7eee">&#9670;&nbsp;</a></span>element_get_face_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_face_shape </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the shape of the face of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element shape of the face. I.e. T8_ECLASS_LINE for quads, T8_ECLASS_TRIANGLE for tets and depending on the face number either T8_ECLASS_QUAD or T8_ECLASS_TRIANGLE for prisms. </dd></dl>

</div>
</div>
<a id="a5f7dd1cdde1132311f1c1300aa729ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7dd1cdde1132311f1c1300aa729ed4">&#9670;&nbsp;</a></span>element_get_first_descendant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_first_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the first descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The first element in a uniform refinement of <em>elem</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb113ca47b3ffc8e5ecb65000a943f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb113ca47b3ffc8e5ecb65000a943f1">&#9670;&nbsp;</a></span>element_get_first_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_first_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>first_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the first descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first_desc</td><td>An allocated element. This element's data will be filled with the data of the first descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the first descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd550eeb3d3717d65c7723c1cb0dac60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd550eeb3d3717d65c7723c1cb0dac60">&#9670;&nbsp;</a></span>element_get_last_descendant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_last_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the last descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The last element in a uniform refinement of <em>elem</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a528dac6e73c1c9f5dc262325f54155ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528dac6e73c1c9f5dc262325f54155ad">&#9670;&nbsp;</a></span>element_get_last_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_last_descendant_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>last_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the last descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_desc</td><td>An allocated element. This element's data will be filled with the data of the last descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the last descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb4972f1d813518ef3798b2ba712b989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4972f1d813518ef3798b2ba712b989">&#9670;&nbsp;</a></span>element_get_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the level of a particular element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose level should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of <b>elem</b>. </dd></dl>

</div>
</div>
<a id="ad8c2acf05509a07b1dcd9fe6caf3314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c2acf05509a07b1dcd9fe6caf3314f">&#9670;&nbsp;</a></span>element_get_linear_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the linear id of a given element in a hypothetical uniform refinement of a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose id we compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the element. </dd></dl>

</div>
</div>
<a id="a751ea010b320ce07de31bf471cd6d688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751ea010b320ce07de31bf471cd6d688">&#9670;&nbsp;</a></span>element_get_max_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_max_num_faces </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the maximum number of faces of a given element and all of its descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of faces of <em>elem</em> and its descendants. </dd></dl>

</div>
</div>
<a id="a1e13b18f053a080d7527090035588703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e13b18f053a080d7527090035588703">&#9670;&nbsp;</a></span>element_get_nca()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_nca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>nca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nearest common ancestor of two elements. </p>
<p>That is, the element with highest level that still has both given elements as descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first of the two input elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second of the two input elements. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nca</td><td>The storage for this element must exist and match the element class of the child. On output the unique nearest common ancestor of <b>elem1</b> and <b>elem2</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dfc3478b4dd165d0a8278a65e208f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfc3478b4dd165d0a8278a65e208f35">&#9670;&nbsp;</a></span>element_get_num_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_num_children </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children of an element when it is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose number of children is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>elem</em> if it is to be refined. </dd></dl>

</div>
</div>
<a id="a3fdf58ff403924e798772b01d8f9eb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdf58ff403924e798772b01d8f9eb8e">&#9670;&nbsp;</a></span>element_get_num_corners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_num_corners </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of corners of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of corners of <em>elem</em>. </dd></dl>

</div>
</div>
<a id="a4928a7b5adc63e8b786994aef0f904c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4928a7b5adc63e8b786994aef0f904c5">&#9670;&nbsp;</a></span>element_get_num_face_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_num_face_children </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of children of an element's face when the element is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose face is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>face</em> if <em>elem</em> is to be refined. </dd></dl>

</div>
</div>
<a id="a89073b5dfa648aa6083ffa86cfc51949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89073b5dfa648aa6083ffa86cfc51949">&#9670;&nbsp;</a></span>element_get_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_num_faces </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of faces of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces of <em>elem</em>. </dd></dl>

</div>
</div>
<a id="a9666e41ba08e941e0e61ace0efca18bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9666e41ba08e941e0e61ace0efca18bd">&#9670;&nbsp;</a></span>element_get_num_siblings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_num_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of siblings of an element. </p>
<p>That is the number of elements with the same parent (if available). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of siblings of <em>element</em>. Note that this number is &gt;= 1, since we count the element itself as a sibling. Note that the number of siblings is 1 for the root element. </dd></dl>

</div>
</div>
<a id="a32c46a32ff3fdd79119608d0607e316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c46a32ff3fdd79119608d0607e316e">&#9670;&nbsp;</a></span>element_get_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the parent of a given element <b>elem</b> and store it in <b>parent</b>. </p>
<p><b>parent</b> needs to be an existing element. No memory is allocated by this function. <b>elem</b> and <b>parent</b> can point to the same element, then the entries of <b>elem</b> are overwritten by the ones of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose parent will be computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parent</td><td>This element's entries will be overwritten by those of <b>elem's</b> parent. The storage for this element must exist and match the element class of the parent. For a pyramid, for example, it may be either a tetrahedron or a pyramid depending on <b>elem's</b> childid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a454e7106d70aa2a85008ed955a99b30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454e7106d70aa2a85008ed955a99b30d">&#9670;&nbsp;</a></span>element_get_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>ref_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point in the reference space of an element to a point in the reference space of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_coords</td><td>The coordinates of the point in the reference space of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coords</td><td>The number of coordinates to evaluate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_coords</td><td>The coordinates of the point in the reference space of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aebbdf67fedfa88262acecf462b761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aebbdf67fedfa88262acecf462b761c">&#9670;&nbsp;</a></span>element_get_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_shape </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the shape of an allocated element according its type. </p>
<p>For example, a child of an element can be an element of a different shape and has to be handled differently - according to its shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shape of the element as an eclass </dd></dl>

</div>
</div>
<a id="a0595cdfdcf8c3662b192782f58233750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0595cdfdcf8c3662b192782f58233750">&#9670;&nbsp;</a></span>element_get_sibling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_sibling </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>sibid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>sibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a specific sibling of a given element <b>elem</b> and store it in <b>sibling</b>. </p>
<p><b>sibling</b> needs to be an existing element. No memory is allocated by this function. <b>elem</b> and <b>sibling</b> can point to the same element, then the entries of <b>elem</b> are overwritten by the ones of its sibid-th sibling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose sibling will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sibid</td><td>The id of the sibling computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sibling</td><td>This element's entries will be overwritten by those of <b>elem's</b> sibid-th sibling. The storage for this element must exist and match the element class of the sibling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66f14671a6d813d14a02acf8a84485f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f14671a6d813d14a02acf8a84485f0">&#9670;&nbsp;</a></span>element_get_tree_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_tree_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an element and a face of this element. </p>
<p>If the face lies on the tree boundary, return the face number of the tree face. If not the return value is arbitrary. You can call <a class="el" href="t8__scheme_8h.html#ae983e976c1666e63fa154e682f1053ad">t8_element_is_root_boundary</a> to query whether the face is at the tree boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of a face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the tree face that <em>face</em> is a subface of, if <em>face</em> is on a tree boundary. Any arbitrary integer if <em>is</em> not at a tree boundary. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The return value may look like a valid face of the tree even if the element does not lie on the root boundary. </dd></dl>

</div>
</div>
<a id="a0898db02cc70df0bd29b6b0c6aaebf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0898db02cc70df0bd29b6b0c6aaebf02">&#9670;&nbsp;</a></span>element_get_vertex_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_get_vertex_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The id of the vertex whose coordinates shall be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>An array of at least as many doubles as the element's dimension whose entries will be filled with the coordinates of <em>vertex</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a943444f20744f36890004c48b44723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a943444f20744f36890004c48b44723">&#9670;&nbsp;</a></span>element_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_init </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be initialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <b>length</b> many allocated elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In debugging mode, an element that was passed to <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> must pass <a class="el" href="structt8__standalone__scheme.html#a4bdff14dbf8ea45c7e9dadd22d832283">element_is_valid</a>. </dd>
<dd>
If an element was created by <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> then <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> may not be called for it. Thus, <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> should initialize an element in the same way as a call to <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> would. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3" title="Allocate memory for an array of elements of a given class and initialize them.">element_new</a> </dd>
<dd>
<a class="el" href="structt8__standalone__scheme.html#a4bdff14dbf8ea45c7e9dadd22d832283" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">element_is_valid</a> </dd></dl>

</div>
</div>
<a id="abc1a7d7da60741b0bfd36e28c2ec6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1a7d7da60741b0bfd36e28c2ec6feb">&#9670;&nbsp;</a></span>element_is_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two elements are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elements are equal, false if they are not equal </dd></dl>

</div>
</div>
<a id="a421e00640ef800432aadc5058358eaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421e00640ef800432aadc5058358eaa3">&#9670;&nbsp;</a></span>element_is_refinable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_is_refinable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if an element is refinable. </p>
<p>Possible reasons for being not refinable could be that the element has reached its max level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element is refinable. </dd></dl>

</div>
</div>
<a id="af4a3ebd2ceea871448f111a8ee33ed6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a3ebd2ceea871448f111a8ee33ed6f">&#9670;&nbsp;</a></span>element_is_root_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_is_root_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether a given element shares a given face with its root tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>face</em> is a subface of the element's root element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can compute the corresponding face number of the tree via <a class="el" href="structt8__standalone__scheme.html#a66f14671a6d813d14a02acf8a84485f0">element_get_tree_face</a>. </dd></dl>

</div>
</div>
<a id="a4bdff14dbf8ea45c7e9dadd22d832283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdff14dbf8ea45c7e9dadd22d832283">&#9670;&nbsp;</a></span>element_is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it. </p>
<p>For example this could mean that all coordinates are in valid ranges and other membervariables do have meaningful values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>elem</em> is safe to use. False otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>An element that is constructed with <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> must pass this test. </dd>
<dd>
An element for which <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> was called must pass this test. </dd>
<dd>
This function is used for debugging to catch certain errors. These can for example occur when an element points to a region of memory which should not be interpreted as an element. </dd>
<dd>
We recommend to use the assertion T8_ASSERT (element_is_valid (elem)) in the implementation of each of the functions in this file. </dd></dl>

</div>
</div>
<a id="a7b07163dec0f3fbc5b828b6598ff3a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b07163dec0f3fbc5b828b6598ff3a1d">&#9670;&nbsp;</a></span>element_MPI_Pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_MPI_Pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack multiple elements into contiguous memory, so they can be sent via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of elements that are to be packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">send_buffer</td><td>Buffer in which to pack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f9954f610322a9766c00e20df0bc0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9954f610322a9766c00e20df0bc0c4">&#9670;&nbsp;</a></span>element_MPI_Pack_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_MPI_Pack_size </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine an upper bound for the size of the packed message of <em>count</em> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pack_size</td><td>upper bound on the message size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68452e2231d8b3281029cceb4132824b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68452e2231d8b3281029cceb4132824b">&#9670;&nbsp;</a></span>element_MPI_Unpack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_MPI_Unpack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack multiple elements from contiguous memory that was received via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvbuf</td><td>Buffer from which to unpack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of initialised elements that is to be filled from the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to unpack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45b39465767ba3abbdc18049af817ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b39465767ba3abbdc18049af817ed3">&#9670;&nbsp;</a></span>element_new()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_new </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for an array of elements of a given class and initialize them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of elements to be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elems</td><td>On input an array of <b>length</b> many unallocated element pointers. On output all these pointers will point to an allocated and initialized element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not every element that is created in t8code will be created by a call to this function. However, if an element is not created using <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a>, then it is guaranteed that <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> is called on it. </dd>
<dd>
In debugging mode, an element that was created with <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> must pass <a class="el" href="structt8__standalone__scheme.html#a4bdff14dbf8ea45c7e9dadd22d832283">element_is_valid</a>. </dd>
<dd>
If an element was created by <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> then <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> may not be called for it. Thus, <a class="el" href="structt8__standalone__scheme.html#a45b39465767ba3abbdc18049af817ed3">element_new</a> should initialize an element in the same way as a call to <a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723">element_init</a> would. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structt8__standalone__scheme.html#a0a943444f20744f36890004c48b44723" title="Initialize an array of allocated elements.">element_init</a> </dd>
<dd>
<a class="el" href="structt8__standalone__scheme.html#a4bdff14dbf8ea45c7e9dadd22d832283" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">element_is_valid</a> </dd></dl>

</div>
</div>
<a id="a9b7988c76b1416521f211835429c39e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7988c76b1416521f211835429c39e9">&#9670;&nbsp;</a></span>element_set_linear_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_set_linear_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const t8_element_level&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the entries of an allocated element according to a given linear id in a uniform refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element whose entries will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The linear id. id must fulfil 0 &lt;= id &lt; 'number of leaves in the uniform refinement' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41f0df60159857ecbf95a918b621a157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0df60159857ecbf95a918b621a157">&#9670;&nbsp;</a></span>element_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>debug_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>string_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a string with readable information about the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to translate into human-readable information </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">debug_string</td><td>The string to fill. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string_size</td><td>Buffer size of c-string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa53d296eee52281323c84a4fdde63773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53d296eee52281323c84a4fdde63773">&#9670;&nbsp;</a></span>element_transform_face() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppose we have two trees that share a common face f. </p>
<p>Given an element e that is a subface of f in one of the trees and given the orientation of the tree connection, construct the face element of the respective tree neighbor that logically coincides with e but lies in the coordinate system of the neighbor tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respective to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientation). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a16f63ec27654fb89fdfafcb02c885416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f63ec27654fb89fdfafcb02c885416">&#9670;&nbsp;</a></span>element_transform_face() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9ac4ce741ff4e19d3e94aa1eb0c0e7abbd">T8_ECLASS_VERTEX</a> &gt;::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppose we have two trees that share a common face f. </p>
<p>Given an element e that is a subface of f in one of the trees and given the orientation of the tree connection, construct the face element of the respective tree neighbor that logically coincides with e but lies in the coordinate system of the neighbor tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respective to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientation). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="ad58a6d2d5f450c9dbfff59e1b65b79e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58a6d2d5f450c9dbfff59e1b65b79e1">&#9670;&nbsp;</a></span>element_transform_face() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a9b6ce2fd6e9d06384a008edf8707f288">T8_ECLASS_TRIANGLE</a> &gt;::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> for triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respective to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientation). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="ad5123e07eeed9f95914deb672883b5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5123e07eeed9f95914deb672883b5c4">&#9670;&nbsp;</a></span>element_transform_face() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a81e3f71a30727a94fc1c80da130297a9">T8_ECLASS_QUAD</a> &gt;::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> for quads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respective to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientation). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="ae31dc674de1686b2cc690d92f7f83086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31dc674de1686b2cc690d92f7f83086">&#9670;&nbsp;</a></span>element_transform_face() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; <a class="el" href="t8__eclass_8h.html#ab20dcd46b3a346d537c1fe8626d579f9a9667a79817957d7f2446d73a9778b8b5">T8_ECLASS_LINE</a> &gt;::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="structt8__standalone__scheme.html#aa53d296eee52281323c84a4fdde63773">element_transform_face</a> for lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respective to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientation). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a3fd65898bb1783d0d5d986dc4cee8e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd65898bb1783d0d5d986dc4cee8e12">&#9670;&nbsp;</a></span>elements_are_family()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::elements_are_family </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *&#160;</td>
          <td class="paramname"><em>fam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether a given set of elements is a family or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fam</td><td>An array of as many elements as an element of class <b>ts</b> has siblings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if <b>fam</b> is not a family, nonzero if it is. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>level 0 elements do not form a family. </dd></dl>

</div>
</div>
<a id="af303185962c4752994785883d9d993f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af303185962c4752994785883d9d993f8">&#9670;&nbsp;</a></span>get_eclass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a> <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::get_eclass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tree class of this scheme. </p>
<dl class="section return"><dt>Returns</dt><dd>The tree class of this scheme. </dd></dl>

</div>
</div>
<a id="a6016f0d4a576740b267eb494791f4397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6016f0d4a576740b267eb494791f4397">&#9670;&nbsp;</a></span>get_element_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::get_element_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of any element of a given class. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of an element. </dd></dl>

</div>
</div>
<a id="aacff8e813905edccbb9c54e5b0665874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacff8e813905edccbb9c54e5b0665874">&#9670;&nbsp;</a></span>get_max_num_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::get_max_num_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the max number of children of an eclass. </p>
<dl class="section return"><dt>Returns</dt><dd>The max number of children of <em>element</em>. </dd></dl>

</div>
</div>
<a id="a0e60c011d267dcc856ff77e3c48765eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e60c011d267dcc856ff77e3c48765eb">&#9670;&nbsp;</a></span>get_maxlevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::get_maxlevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum allowed level for any element of a given class. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed level for elements of class <b>ts</b>. </dd></dl>

</div>
</div>
<a id="a1d1ff32174e03693c720ed49c9bd1c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1ff32174e03693c720ed49c9bd1c81">&#9670;&nbsp;</a></span>refines_irregular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::refines_irregular </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if there is one element in the tree, that does not refine into 2^dim children. </p>
<p>Returns false otherwise. </p><dl class="section return"><dt>Returns</dt><dd>non-zero if there is one element in the tree that does not refine into 2^dim children. </dd></dl>

</div>
</div>
<a id="a39c8a868274d577c587b188e7179d1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c8a868274d577c587b188e7179d1e5">&#9670;&nbsp;</a></span>set_to_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;t8_eclass TEclass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void <a class="el" href="structt8__standalone__scheme.html">t8_standalone_scheme</a>&lt; TEclass &gt;::set_to_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create the root element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element that is filled with the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/t8_schemes/t8_standalone/<a class="el" href="t8__standalone__implementation_8hxx_source.html">t8_standalone_implementation.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
