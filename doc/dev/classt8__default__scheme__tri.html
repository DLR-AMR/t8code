<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t8: t8_default_scheme_tri Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">t8
   &#160;<span id="projectnumber">4.0.0-RC2.318-b667f</span>
   </div>
   <div id="projectbrief">t8code is a C library to manage a forest of adaptive                           space-trees of general element classes in parallel.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">t8_default_scheme_tri Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Default implementation of the scheme for the triangular element class.  
 <a href="classt8__default__scheme__tri.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="t8__default__tri_8hxx_source.html">t8_default_tri.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for t8_default_scheme_tri:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classt8__default__scheme__tri.png" usemap="#t8_5Fdefault_5Fscheme_5Ftri_map" alt=""/>
  <map id="t8_5Fdefault_5Fscheme_5Ftri_map" name="t8_5Fdefault_5Fscheme_5Ftri_map">
<area href="classt8__default__scheme__common.html" alt="t8_default_scheme_common&lt; t8_default_scheme_tri &gt;" shape="rect" coords="0,56,420,80"/>
<area href="structt8__crtp__operator.html" title="The CRTP pattern for operators." alt="t8_crtp_operator&lt; TUnderlying, crtpType &gt;" shape="rect" coords="0,0,420,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac246b8461b69574523d6369c50e0149c"><td class="memItemLeft" align="right" valign="top"><a id="ac246b8461b69574523d6369c50e0149c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#ac246b8461b69574523d6369c50e0149c">t8_default_scheme_tri</a> () noexcept</td></tr>
<tr class="memdesc:ac246b8461b69574523d6369c50e0149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which calls the specialized constructor for the base. <br /></td></tr>
<tr class="separator:ac246b8461b69574523d6369c50e0149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e39102e5703bb7409da6e16b2e74f9"><td class="memItemLeft" align="right" valign="top"><a id="af0e39102e5703bb7409da6e16b2e74f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#af0e39102e5703bb7409da6e16b2e74f9">~t8_default_scheme_tri</a> ()</td></tr>
<tr class="memdesc:af0e39102e5703bb7409da6e16b2e74f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:af0e39102e5703bb7409da6e16b2e74f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd1210c84c61290fe896e7fd7d8b6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a24dd1210c84c61290fe896e7fd7d8b6d">get_element_size</a> (void) const</td></tr>
<tr class="memdesc:a24dd1210c84c61290fe896e7fd7d8b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of a tri element.  <a href="classt8__default__scheme__tri.html#a24dd1210c84c61290fe896e7fd7d8b6d">More...</a><br /></td></tr>
<tr class="separator:a24dd1210c84c61290fe896e7fd7d8b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a6220d0d473947eae19383f309c85d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> (int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elem) const</td></tr>
<tr class="memdesc:a53a6220d0d473947eae19383f309c85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for an array of triangles and initialize them.  <a href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">More...</a><br /></td></tr>
<tr class="separator:a53a6220d0d473947eae19383f309c85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc89b85c198baebdba5067c3239ee7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> (int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:adc89b85c198baebdba5067c3239ee7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of allocated tri elements.  <a href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">More...</a><br /></td></tr>
<tr class="separator:adc89b85c198baebdba5067c3239ee7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e813fd9281d40f4c14aaf7b061cd6c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a4e813fd9281d40f4c14aaf7b061cd6c2">element_get_level</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a4e813fd9281d40f4c14aaf7b061cd6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the refinement level of an element.  <a href="classt8__default__scheme__tri.html#a4e813fd9281d40f4c14aaf7b061cd6c2">More...</a><br /></td></tr>
<tr class="separator:a4e813fd9281d40f4c14aaf7b061cd6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f00f65c7feb8af5f7cecced39e98bab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a3f00f65c7feb8af5f7cecced39e98bab">get_maxlevel</a> (void) const</td></tr>
<tr class="memdesc:a3f00f65c7feb8af5f7cecced39e98bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowed level for this element class.  <a href="classt8__default__scheme__tri.html#a3f00f65c7feb8af5f7cecced39e98bab">More...</a><br /></td></tr>
<tr class="separator:a3f00f65c7feb8af5f7cecced39e98bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4024674b091abd09c748aee432d161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a3f4024674b091abd09c748aee432d161">element_copy</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *source, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *dest) const</td></tr>
<tr class="memdesc:a3f4024674b091abd09c748aee432d161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all entries of <b>source</b> to <b>dest</b>.  <a href="classt8__default__scheme__tri.html#a3f4024674b091abd09c748aee432d161">More...</a><br /></td></tr>
<tr class="separator:a3f4024674b091abd09c748aee432d161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab844974b36df6486aaac80627b1cd128"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#ab844974b36df6486aaac80627b1cd128">element_compare</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) const</td></tr>
<tr class="memdesc:ab844974b36df6486aaac80627b1cd128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two elements.  <a href="classt8__default__scheme__tri.html#ab844974b36df6486aaac80627b1cd128">More...</a><br /></td></tr>
<tr class="separator:ab844974b36df6486aaac80627b1cd128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c67b99ef314de05b75d4bc946b8f8d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a3c67b99ef314de05b75d4bc946b8f8d7">element_is_equal</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2) const</td></tr>
<tr class="memdesc:a3c67b99ef314de05b75d4bc946b8f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two elements are equal.  <a href="classt8__default__scheme__tri.html#a3c67b99ef314de05b75d4bc946b8f8d7">More...</a><br /></td></tr>
<tr class="separator:a3c67b99ef314de05b75d4bc946b8f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa56c7a46cd8e8e810efcb9b7d6143d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a5fa56c7a46cd8e8e810efcb9b7d6143d">element_get_parent</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *parent) const</td></tr>
<tr class="memdesc:a5fa56c7a46cd8e8e810efcb9b7d6143d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the parent of a given element <b>elem</b> and store it in <b>parent</b>.  <a href="classt8__default__scheme__tri.html#a5fa56c7a46cd8e8e810efcb9b7d6143d">More...</a><br /></td></tr>
<tr class="separator:a5fa56c7a46cd8e8e810efcb9b7d6143d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbf46899d79c103d24b9073fc3dae27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a3fbf46899d79c103d24b9073fc3dae27">element_get_sibling</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int sibid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *sibling) const</td></tr>
<tr class="memdesc:a3fbf46899d79c103d24b9073fc3dae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a specific sibling of a given tri element <b>elem</b> and store it in <b>sibling</b>.  <a href="classt8__default__scheme__tri.html#a3fbf46899d79c103d24b9073fc3dae27">More...</a><br /></td></tr>
<tr class="separator:a3fbf46899d79c103d24b9073fc3dae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d048afb1db9ee454f6caa7fce91c254"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a4d048afb1db9ee454f6caa7fce91c254">element_get_num_faces</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a4d048afb1db9ee454f6caa7fce91c254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of faces of a given element.  <a href="classt8__default__scheme__tri.html#a4d048afb1db9ee454f6caa7fce91c254">More...</a><br /></td></tr>
<tr class="separator:a4d048afb1db9ee454f6caa7fce91c254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea955210c542b4d937b8ce8614f8d57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#aeea955210c542b4d937b8ce8614f8d57">element_get_max_num_faces</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:aeea955210c542b4d937b8ce8614f8d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum number of faces of a given element and all of its descendants.  <a href="classt8__default__scheme__tri.html#aeea955210c542b4d937b8ce8614f8d57">More...</a><br /></td></tr>
<tr class="separator:aeea955210c542b4d937b8ce8614f8d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab857fe11918a6ad688d8c41f3a37fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a3ab857fe11918a6ad688d8c41f3a37fb">element_get_num_children</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a3ab857fe11918a6ad688d8c41f3a37fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element when it is refined.  <a href="classt8__default__scheme__tri.html#a3ab857fe11918a6ad688d8c41f3a37fb">More...</a><br /></td></tr>
<tr class="separator:a3ab857fe11918a6ad688d8c41f3a37fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b54a223b4dbd5c104b335603f74a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a8c9b54a223b4dbd5c104b335603f74a4">element_get_num_face_children</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face) const</td></tr>
<tr class="memdesc:a8c9b54a223b4dbd5c104b335603f74a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of an element's face when the element is refined.  <a href="classt8__default__scheme__tri.html#a8c9b54a223b4dbd5c104b335603f74a4">More...</a><br /></td></tr>
<tr class="separator:a8c9b54a223b4dbd5c104b335603f74a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6f24fd0e41e010236e829598b99639"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a4f6f24fd0e41e010236e829598b99639">element_get_face_corner</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, int face, int corner) const</td></tr>
<tr class="memdesc:a4f6f24fd0e41e010236e829598b99639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corner number of an element's face corner.  <a href="classt8__default__scheme__tri.html#a4f6f24fd0e41e010236e829598b99639">More...</a><br /></td></tr>
<tr class="separator:a4f6f24fd0e41e010236e829598b99639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bf4b3ba26704dcb11c472c4682023a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a62bf4b3ba26704dcb11c472c4682023a">element_get_corner_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, int corner, int face) const</td></tr>
<tr class="memdesc:a62bf4b3ba26704dcb11c472c4682023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the face numbers of the faces sharing an element's corner.  <a href="classt8__default__scheme__tri.html#a62bf4b3ba26704dcb11c472c4682023a">More...</a><br /></td></tr>
<tr class="separator:a62bf4b3ba26704dcb11c472c4682023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8d868c0980b89507ceb02b63e1ee47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a1e8d868c0980b89507ceb02b63e1ee47">element_get_child</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int childid, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *child) const</td></tr>
<tr class="memdesc:a1e8d868c0980b89507ceb02b63e1ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the child element of a given number.  <a href="classt8__default__scheme__tri.html#a1e8d868c0980b89507ceb02b63e1ee47">More...</a><br /></td></tr>
<tr class="separator:a1e8d868c0980b89507ceb02b63e1ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5d668a6269fe8802bc4f133d422528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#abc5d668a6269fe8802bc4f133d422528">element_get_children</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *c[]) const</td></tr>
<tr class="memdesc:abc5d668a6269fe8802bc4f133d422528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct all children of a given element.  <a href="classt8__default__scheme__tri.html#abc5d668a6269fe8802bc4f133d422528">More...</a><br /></td></tr>
<tr class="separator:abc5d668a6269fe8802bc4f133d422528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a4aaf7bd9f71de748bb638498fdcab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a81a4aaf7bd9f71de748bb638498fdcab">element_get_child_id</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a81a4aaf7bd9f71de748bb638498fdcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the child id of an element.  <a href="classt8__default__scheme__tri.html#a81a4aaf7bd9f71de748bb638498fdcab">More...</a><br /></td></tr>
<tr class="separator:a81a4aaf7bd9f71de748bb638498fdcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd03067fd8eba757c06751ea59059b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a9dd03067fd8eba757c06751ea59059b1">element_get_ancestor_id</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int level) const</td></tr>
<tr class="memdesc:a9dd03067fd8eba757c06751ea59059b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ancestor id of an element, that is the child id at a given level.  <a href="classt8__default__scheme__tri.html#a9dd03067fd8eba757c06751ea59059b1">More...</a><br /></td></tr>
<tr class="separator:a9dd03067fd8eba757c06751ea59059b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ee998b536f103d72a7a64a260eb923"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a41ee998b536f103d72a7a64a260eb923">elements_are_family</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *fam) const</td></tr>
<tr class="memdesc:a41ee998b536f103d72a7a64a260eb923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given set of elements is a family or not.  <a href="classt8__default__scheme__tri.html#a41ee998b536f103d72a7a64a260eb923">More...</a><br /></td></tr>
<tr class="separator:a41ee998b536f103d72a7a64a260eb923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134702050c17d4cfdd7a0c0bae865faa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a134702050c17d4cfdd7a0c0bae865faa">element_get_nca</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *nca) const</td></tr>
<tr class="memdesc:a134702050c17d4cfdd7a0c0bae865faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nearest common ancestor of two elements.  <a href="classt8__default__scheme__tri.html#a134702050c17d4cfdd7a0c0bae865faa">More...</a><br /></td></tr>
<tr class="separator:a134702050c17d4cfdd7a0c0bae865faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efd463f38684143c60f062683e1b557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a5efd463f38684143c60f062683e1b557">element_get_face_shape</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face) const</td></tr>
<tr class="memdesc:a5efd463f38684143c60f062683e1b557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shape of the face of an element.  <a href="classt8__default__scheme__tri.html#a5efd463f38684143c60f062683e1b557">More...</a><br /></td></tr>
<tr class="separator:a5efd463f38684143c60f062683e1b557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7415aabf2dc8d8908dd727fededbf2e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a7415aabf2dc8d8908dd727fededbf2e4">element_get_children_at_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *children[], int num_children, int *child_indices) const</td></tr>
<tr class="memdesc:a7415aabf2dc8d8908dd727fededbf2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of the element, compute all children of the element that touch the face.  <a href="classt8__default__scheme__tri.html#a7415aabf2dc8d8908dd727fededbf2e4">More...</a><br /></td></tr>
<tr class="separator:a7415aabf2dc8d8908dd727fededbf2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5e43eb9d545c4385eed40d023e2798"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a4c5e43eb9d545c4385eed40d023e2798">element_face_get_child_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, int face_child) const</td></tr>
<tr class="memdesc:a4c5e43eb9d545c4385eed40d023e2798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face.  <a href="classt8__default__scheme__tri.html#a4c5e43eb9d545c4385eed40d023e2798">More...</a><br /></td></tr>
<tr class="separator:a4c5e43eb9d545c4385eed40d023e2798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6f2945d5b9305a65f803b965bd8bd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#acc6f2945d5b9305a65f803b965bd8bd9">element_face_get_parent_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face) const</td></tr>
<tr class="memdesc:acc6f2945d5b9305a65f803b965bd8bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a face of an element return the face number of the parent of the element that matches the element's face.  <a href="classt8__default__scheme__tri.html#acc6f2945d5b9305a65f803b965bd8bd9">More...</a><br /></td></tr>
<tr class="separator:acc6f2945d5b9305a65f803b965bd8bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9267c67356ba53d1dd4ce6119328d89b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a9267c67356ba53d1dd4ce6119328d89b">element_get_tree_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face) const</td></tr>
<tr class="memdesc:a9267c67356ba53d1dd4ce6119328d89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an element and a face of this element.  <a href="classt8__default__scheme__tri.html#a9267c67356ba53d1dd4ce6119328d89b">More...</a><br /></td></tr>
<tr class="separator:a9267c67356ba53d1dd4ce6119328d89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85425ac5930a92d365f83968f4bf6135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a85425ac5930a92d365f83968f4bf6135">element_transform_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem1, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem2, int orientation, int sign, int is_smaller_face) const</td></tr>
<tr class="memdesc:a85425ac5930a92d365f83968f4bf6135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppose we have two trees that share a common face f.  <a href="classt8__default__scheme__tri.html#a85425ac5930a92d365f83968f4bf6135">More...</a><br /></td></tr>
<tr class="separator:a85425ac5930a92d365f83968f4bf6135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bbf0e779c377ab4b9b0dace4ebfbb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#af9bbf0e779c377ab4b9b0dace4ebfbb0">element_extrude_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int root_face, const <a class="el" href="classt8__scheme.html">t8_scheme</a> *scheme) const</td></tr>
<tr class="memdesc:af9bbf0e779c377ab4b9b0dace4ebfbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face.  <a href="classt8__default__scheme__tri.html#af9bbf0e779c377ab4b9b0dace4ebfbb0">More...</a><br /></td></tr>
<tr class="separator:af9bbf0e779c377ab4b9b0dace4ebfbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3791112001fb9a8320058d54cb6a72a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#ad3791112001fb9a8320058d54cb6a72a">element_get_first_descendant_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *first_desc, int level) const</td></tr>
<tr class="memdesc:ad3791112001fb9a8320058d54cb6a72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the first descendant of an element at a given level that touches a given face.  <a href="classt8__default__scheme__tri.html#ad3791112001fb9a8320058d54cb6a72a">More...</a><br /></td></tr>
<tr class="separator:ad3791112001fb9a8320058d54cb6a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0a052a363e14379e22cf02fbb04716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a3f0a052a363e14379e22cf02fbb04716">element_get_last_descendant_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *last_desc, int level) const</td></tr>
<tr class="memdesc:a3f0a052a363e14379e22cf02fbb04716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the last descendant of an element at a given level that touches a given face.  <a href="classt8__default__scheme__tri.html#a3f0a052a363e14379e22cf02fbb04716">More...</a><br /></td></tr>
<tr class="separator:a3f0a052a363e14379e22cf02fbb04716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03de1542bc0a9c76dc2f927fe5be07a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#ac03de1542bc0a9c76dc2f927fe5be07a">element_get_boundary_face</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *boundary, const <a class="el" href="classt8__scheme.html">t8_scheme</a> *scheme) const</td></tr>
<tr class="memdesc:ac03de1542bc0a9c76dc2f927fe5be07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the boundary element at a specific face.  <a href="classt8__default__scheme__tri.html#ac03de1542bc0a9c76dc2f927fe5be07a">More...</a><br /></td></tr>
<tr class="separator:ac03de1542bc0a9c76dc2f927fe5be07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a256aa53bdf0fd5ffccd17421bc245d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a2a256aa53bdf0fd5ffccd17421bc245d">element_is_root_boundary</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int face) const</td></tr>
<tr class="memdesc:a2a256aa53bdf0fd5ffccd17421bc245d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether a given element shares a given face with its root tree.  <a href="classt8__default__scheme__tri.html#a2a256aa53bdf0fd5ffccd17421bc245d">More...</a><br /></td></tr>
<tr class="separator:a2a256aa53bdf0fd5ffccd17421bc245d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758a0209670c6c2c756c6163b9cae8c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a758a0209670c6c2c756c6163b9cae8c9">element_get_face_neighbor_inside</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *neigh, int face, int *neigh_face) const</td></tr>
<tr class="memdesc:a758a0209670c6c2c756c6163b9cae8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the face neighbor of a given element if this face neighbor is inside the root tree.  <a href="classt8__default__scheme__tri.html#a758a0209670c6c2c756c6163b9cae8c9">More...</a><br /></td></tr>
<tr class="separator:a758a0209670c6c2c756c6163b9cae8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af010d4a39286135ee87e46326e79c818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#af010d4a39286135ee87e46326e79c818">element_set_linear_id</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int level, <a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> id) const</td></tr>
<tr class="memdesc:af010d4a39286135ee87e46326e79c818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the entries of an allocated element according to a given linear id in a uniform refinement.  <a href="classt8__default__scheme__tri.html#af010d4a39286135ee87e46326e79c818">More...</a><br /></td></tr>
<tr class="separator:af010d4a39286135ee87e46326e79c818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58df62c19d183229de2b2c63fcdceeb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a58df62c19d183229de2b2c63fcdceeb0">element_get_linear_id</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int level) const</td></tr>
<tr class="memdesc:a58df62c19d183229de2b2c63fcdceeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the linear id of a given element in a hypothetical uniform refinement of a given level.  <a href="classt8__default__scheme__tri.html#a58df62c19d183229de2b2c63fcdceeb0">More...</a><br /></td></tr>
<tr class="separator:a58df62c19d183229de2b2c63fcdceeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c0013033e71c0f28ebed889222dec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a36c0013033e71c0f28ebed889222dec6">element_get_first_descendant</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, int level) const</td></tr>
<tr class="memdesc:a36c0013033e71c0f28ebed889222dec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first descendant of a given element.  <a href="classt8__default__scheme__tri.html#a36c0013033e71c0f28ebed889222dec6">More...</a><br /></td></tr>
<tr class="separator:a36c0013033e71c0f28ebed889222dec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9d0cc7e39d491538fe8cc1b1d8a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a1ff9d0cc7e39d491538fe8cc1b1d8a7f">element_get_last_descendant</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *desc, int level) const</td></tr>
<tr class="memdesc:a1ff9d0cc7e39d491538fe8cc1b1d8a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the last descendant of a given element.  <a href="classt8__default__scheme__tri.html#a1ff9d0cc7e39d491538fe8cc1b1d8a7f">More...</a><br /></td></tr>
<tr class="separator:a1ff9d0cc7e39d491538fe8cc1b1d8a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e531db662a070409a45fc03c053fe79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a6e531db662a070409a45fc03c053fe79">element_construct_successor</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *succ) const</td></tr>
<tr class="memdesc:a6e531db662a070409a45fc03c053fe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the successor in a uniform refinement of a given element.  <a href="classt8__default__scheme__tri.html#a6e531db662a070409a45fc03c053fe79">More...</a><br /></td></tr>
<tr class="separator:a6e531db662a070409a45fc03c053fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dabbbaa590723f847cf666e0c463c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a9dabbbaa590723f847cf666e0c463c81">element_get_anchor</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int anchor[3]) const</td></tr>
<tr class="memdesc:a9dabbbaa590723f847cf666e0c463c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer coordinates of the anchor node of an element.  <a href="classt8__default__scheme__tri.html#a9dabbbaa590723f847cf666e0c463c81">More...</a><br /></td></tr>
<tr class="separator:a9dabbbaa590723f847cf666e0c463c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1483034161e1f0e707b2ced8047a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a6b1483034161e1f0e707b2ced8047a00">element_get_vertex_integer_coords</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, int vertex, int coords[]) const</td></tr>
<tr class="memdesc:a6b1483034161e1f0e707b2ced8047a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer coordinates of a given element vertex.  <a href="classt8__default__scheme__tri.html#a6b1483034161e1f0e707b2ced8047a00">More...</a><br /></td></tr>
<tr class="separator:a6b1483034161e1f0e707b2ced8047a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4df1a120a1a623755f540c2aa57e60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a2f4df1a120a1a623755f540c2aa57e60">element_get_vertex_reference_coords</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const int vertex, double coords[]) const</td></tr>
<tr class="memdesc:a2f4df1a120a1a623755f540c2aa57e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension).  <a href="classt8__default__scheme__tri.html#a2f4df1a120a1a623755f540c2aa57e60">More...</a><br /></td></tr>
<tr class="separator:a2f4df1a120a1a623755f540c2aa57e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35adf980ecc3a6657bffcc38be7da96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#ab35adf980ecc3a6657bffcc38be7da96">element_get_reference_coords</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, const double *ref_coords, const size_t num_coords, double *out_coords) const</td></tr>
<tr class="memdesc:ab35adf980ecc3a6657bffcc38be7da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points in the reference space of an element to points in the reference space of the tree.  <a href="classt8__default__scheme__tri.html#ab35adf980ecc3a6657bffcc38be7da96">More...</a><br /></td></tr>
<tr class="separator:ab35adf980ecc3a6657bffcc38be7da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdc95dba298093d67fc25120f38a240"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#adcdc95dba298093d67fc25120f38a240">refines_irregular</a> (void) const</td></tr>
<tr class="memdesc:adcdc95dba298093d67fc25120f38a240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if there is one element in the tree, that does not refine into 2^dim children.  <a href="classt8__default__scheme__tri.html#adcdc95dba298093d67fc25120f38a240">More...</a><br /></td></tr>
<tr class="separator:adcdc95dba298093d67fc25120f38a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb699e44f0a6f62397cc554e5d6dbf07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#afb699e44f0a6f62397cc554e5d6dbf07">element_is_valid</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element) const</td></tr>
<tr class="memdesc:afb699e44f0a6f62397cc554e5d6dbf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it.  <a href="classt8__default__scheme__tri.html#afb699e44f0a6f62397cc554e5d6dbf07">More...</a><br /></td></tr>
<tr class="separator:afb699e44f0a6f62397cc554e5d6dbf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1199e2d12da956b554473273677b26b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a1199e2d12da956b554473273677b26b4">element_to_string</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem, char *debug_string, const int string_size) const</td></tr>
<tr class="memdesc:a1199e2d12da956b554473273677b26b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a given element.  <a href="classt8__default__scheme__tri.html#a1199e2d12da956b554473273677b26b4">More...</a><br /></td></tr>
<tr class="separator:a1199e2d12da956b554473273677b26b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478e2ae136bb44993533770f34a2b52b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a478e2ae136bb44993533770f34a2b52b">set_to_root</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a478e2ae136bb44993533770f34a2b52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an element with the root element.  <a href="classt8__default__scheme__tri.html#a478e2ae136bb44993533770f34a2b52b">More...</a><br /></td></tr>
<tr class="separator:a478e2ae136bb44993533770f34a2b52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390fe7d224f7b1ac3886a355a0d2bd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a8390fe7d224f7b1ac3886a355a0d2bd7">element_MPI_Pack</a> (<a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const elements, const unsigned int count, void *send_buffer, int buffer_size, int *position, sc_MPI_Comm comm) const</td></tr>
<tr class="memdesc:a8390fe7d224f7b1ac3886a355a0d2bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack multiple elements into contiguous memory, so they can be sent via MPI.  <a href="classt8__default__scheme__tri.html#a8390fe7d224f7b1ac3886a355a0d2bd7">More...</a><br /></td></tr>
<tr class="separator:a8390fe7d224f7b1ac3886a355a0d2bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541e20ae579571247bd11c6872cfdbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#ac541e20ae579571247bd11c6872cfdbd">element_MPI_Pack_size</a> (const unsigned int count, sc_MPI_Comm comm, int *pack_size) const</td></tr>
<tr class="memdesc:ac541e20ae579571247bd11c6872cfdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine an upper bound for the size of the packed message of <b>count</b> elements.  <a href="classt8__default__scheme__tri.html#ac541e20ae579571247bd11c6872cfdbd">More...</a><br /></td></tr>
<tr class="separator:ac541e20ae579571247bd11c6872cfdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682a7f24c38380acd4d60db22da3205b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__tri.html#a682a7f24c38380acd4d60db22da3205b">element_MPI_Unpack</a> (void *recvbuf, const int buffer_size, int *position, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elements, const unsigned int count, sc_MPI_Comm comm) const</td></tr>
<tr class="memdesc:a682a7f24c38380acd4d60db22da3205b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack multiple elements from contiguous memory that was received via MPI.  <a href="classt8__default__scheme__tri.html#a682a7f24c38380acd4d60db22da3205b">More...</a><br /></td></tr>
<tr class="separator:a682a7f24c38380acd4d60db22da3205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classt8__default__scheme__common"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classt8__default__scheme__common')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common&lt; t8_default_scheme_tri &gt;</a></td></tr>
<tr class="memitem:a5b5a90da2b2f16ac12b7b606b670255a inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="a5b5a90da2b2f16ac12b7b606b670255a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a5b5a90da2b2f16ac12b7b606b670255a">t8_default_scheme_common</a> (<a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a5b5a90da2b2f16ac12b7b606b670255a inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a5b5a90da2b2f16ac12b7b606b670255a inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e457b2ea6395f9424f8b870ea8d5ebb inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="a8e457b2ea6395f9424f8b870ea8d5ebb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a8e457b2ea6395f9424f8b870ea8d5ebb">t8_default_scheme_common</a> (const <a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common</a> &amp;other)</td></tr>
<tr class="memdesc:a8e457b2ea6395f9424f8b870ea8d5ebb inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a8e457b2ea6395f9424f8b870ea8d5ebb inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40923bd55b6656b84a90469fd0de9b8a inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="a40923bd55b6656b84a90469fd0de9b8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a40923bd55b6656b84a90469fd0de9b8a">~t8_default_scheme_common</a> ()</td></tr>
<tr class="memdesc:a40923bd55b6656b84a90469fd0de9b8a inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for all default schemes. <br /></td></tr>
<tr class="separator:a40923bd55b6656b84a90469fd0de9b8a inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c1f5ae3062d1df8a4680cc1dd09f7c inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="ac0c1f5ae3062d1df8a4680cc1dd09f7c"></a>
<a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#ac0c1f5ae3062d1df8a4680cc1dd09f7c">operator=</a> (<a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ac0c1f5ae3062d1df8a4680cc1dd09f7c inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:ac0c1f5ae3062d1df8a4680cc1dd09f7c inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6adfdf73c09f637afaf18e6f4477c5e inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="ac6adfdf73c09f637afaf18e6f4477c5e"></a>
<a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#ac6adfdf73c09f637afaf18e6f4477c5e">operator=</a> (const <a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common</a> &amp;other)</td></tr>
<tr class="memdesc:ac6adfdf73c09f637afaf18e6f4477c5e inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:ac6adfdf73c09f637afaf18e6f4477c5e inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eac2ada93152f6f0d14ca7d0a106060 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a1eac2ada93152f6f0d14ca7d0a106060">get_eclass</a> (void) const</td></tr>
<tr class="memdesc:a1eac2ada93152f6f0d14ca7d0a106060 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tree class of this scheme.  <a href="classt8__default__scheme__common.html#a1eac2ada93152f6f0d14ca7d0a106060">More...</a><br /></td></tr>
<tr class="separator:a1eac2ada93152f6f0d14ca7d0a106060 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e35bfebec7f93ac7819fecf4439a45e inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a1e35bfebec7f93ac7819fecf4439a45e">get_element_size</a> (void) const</td></tr>
<tr class="memdesc:a1e35bfebec7f93ac7819fecf4439a45e inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of any element of a given class.  <a href="classt8__default__scheme__common.html#a1e35bfebec7f93ac7819fecf4439a45e">More...</a><br /></td></tr>
<tr class="separator:a1e35bfebec7f93ac7819fecf4439a45e inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef59e3c8677db445aa78620374ec908 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a5ef59e3c8677db445aa78620374ec908">element_get_num_corners</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a5ef59e3c8677db445aa78620374ec908 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of corners of a given element.  <a href="classt8__default__scheme__common.html#a5ef59e3c8677db445aa78620374ec908">More...</a><br /></td></tr>
<tr class="separator:a5ef59e3c8677db445aa78620374ec908 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e8de1cdd47387fa2cf595f126c69b1 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#ae6e8de1cdd47387fa2cf595f126c69b1">get_max_num_children</a> () const</td></tr>
<tr class="memdesc:ae6e8de1cdd47387fa2cf595f126c69b1 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the max number of children of an eclass.  <a href="classt8__default__scheme__common.html#ae6e8de1cdd47387fa2cf595f126c69b1">More...</a><br /></td></tr>
<tr class="separator:ae6e8de1cdd47387fa2cf595f126c69b1 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9445f7a80b2443e24e259f3bff7cc5 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a3c9445f7a80b2443e24e259f3bff7cc5">element_new</a> (const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elem) const</td></tr>
<tr class="memdesc:a3c9445f7a80b2443e24e259f3bff7cc5 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a bunch of elements.  <a href="classt8__default__scheme__common.html#a3c9445f7a80b2443e24e259f3bff7cc5">More...</a><br /></td></tr>
<tr class="separator:a3c9445f7a80b2443e24e259f3bff7cc5 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77acfc5336aa93ae86b8bfaae5dcfac inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="ac77acfc5336aa93ae86b8bfaae5dcfac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#ac77acfc5336aa93ae86b8bfaae5dcfac">element_destroy</a> (const int length, <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **elem) const</td></tr>
<tr class="memdesc:ac77acfc5336aa93ae86b8bfaae5dcfac inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate space for a bunch of elements. <br /></td></tr>
<tr class="separator:ac77acfc5336aa93ae86b8bfaae5dcfac inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd09f36c7ea3c31865a1d40ac8e1e1 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#ab5dd09f36c7ea3c31865a1d40ac8e1e1">element_deinit</a> ([[maybe_unused]] int length,[[maybe_unused]] <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ab5dd09f36c7ea3c31865a1d40ac8e1e1 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize an array of allocated elements.  <a href="classt8__default__scheme__common.html#ab5dd09f36c7ea3c31865a1d40ac8e1e1">More...</a><br /></td></tr>
<tr class="separator:ab5dd09f36c7ea3c31865a1d40ac8e1e1 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3efae46978de715c4164bd8dc63385 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a8f3efae46978de715c4164bd8dc63385">element_get_shape</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a8f3efae46978de715c4164bd8dc63385 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape of an element.  <a href="classt8__default__scheme__common.html#a8f3efae46978de715c4164bd8dc63385">More...</a><br /></td></tr>
<tr class="separator:a8f3efae46978de715c4164bd8dc63385 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b108a80689db44ae6355bd1bffe3c8b inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a3b108a80689db44ae6355bd1bffe3c8b">element_count_leaves</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *element, int level) const</td></tr>
<tr class="memdesc:a3b108a80689db44ae6355bd1bffe3c8b inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level an element would produce.  <a href="classt8__default__scheme__common.html#a3b108a80689db44ae6355bd1bffe3c8b">More...</a><br /></td></tr>
<tr class="separator:a3b108a80689db44ae6355bd1bffe3c8b inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245fab3a8718157d38b0dd336624a28a inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a245fab3a8718157d38b0dd336624a28a">element_is_refinable</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a245fab3a8718157d38b0dd336624a28a inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if an element is refinable.  <a href="classt8__default__scheme__common.html#a245fab3a8718157d38b0dd336624a28a">More...</a><br /></td></tr>
<tr class="separator:a245fab3a8718157d38b0dd336624a28a inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119611a4eb7382b13f36ff6fd6e1d351 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a119611a4eb7382b13f36ff6fd6e1d351">element_get_num_siblings</a> ([[maybe_unused]] const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:a119611a4eb7382b13f36ff6fd6e1d351 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of siblings of an element.  <a href="classt8__default__scheme__common.html#a119611a4eb7382b13f36ff6fd6e1d351">More...</a><br /></td></tr>
<tr class="separator:a119611a4eb7382b13f36ff6fd6e1d351 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade1abc806eafb74d8e3c6c36a002a0b inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a class="el" href="t8_8h.html#a03692467b9ffc84d4d0c37e042679225">t8_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#aade1abc806eafb74d8e3c6c36a002a0b">count_leaves_from_root</a> (const int level) const</td></tr>
<tr class="memdesc:aade1abc806eafb74d8e3c6c36a002a0b inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many leaf descendants of a given uniform level the root element will produce.  <a href="classt8__default__scheme__common.html#aade1abc806eafb74d8e3c6c36a002a0b">More...</a><br /></td></tr>
<tr class="separator:aade1abc806eafb74d8e3c6c36a002a0b inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d1caf4533912c18f66c5bb0cf76c85 inherit pub_methods_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#ab8d1caf4533912c18f66c5bb0cf76c85">element_debug_print</a> (const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *elem) const</td></tr>
<tr class="memdesc:ab8d1caf4533912c18f66c5bb0cf76c85 inherit pub_methods_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a given element.  <a href="classt8__default__scheme__common.html#ab8d1caf4533912c18f66c5bb0cf76c85">More...</a><br /></td></tr>
<tr class="separator:ab8d1caf4533912c18f66c5bb0cf76c85 inherit pub_methods_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structt8__crtp__operator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structt8__crtp__operator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structt8__crtp__operator.html">t8_crtp_operator&lt; TUnderlying, crtpType &gt;</a></td></tr>
<tr class="memitem:a6e33d283003d5653456196f7dfe1568a inherit pub_methods_structt8__crtp__operator"><td class="memItemLeft" align="right" valign="top"><a id="a6e33d283003d5653456196f7dfe1568a"></a>
constexpr TUnderlying &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__crtp__operator.html#a6e33d283003d5653456196f7dfe1568a">underlying</a> () noexcept</td></tr>
<tr class="memdesc:a6e33d283003d5653456196f7dfe1568a inherit pub_methods_structt8__crtp__operator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying type. <br /></td></tr>
<tr class="separator:a6e33d283003d5653456196f7dfe1568a inherit pub_methods_structt8__crtp__operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba1bcc85b8fb7b29cfdb0e60d225774 inherit pub_methods_structt8__crtp__operator"><td class="memItemLeft" align="right" valign="top"><a id="abba1bcc85b8fb7b29cfdb0e60d225774"></a>
constexpr const TUnderlying &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt8__crtp__operator.html#abba1bcc85b8fb7b29cfdb0e60d225774">underlying</a> () const noexcept</td></tr>
<tr class="memdesc:abba1bcc85b8fb7b29cfdb0e60d225774 inherit pub_methods_structt8__crtp__operator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying type. <br /></td></tr>
<tr class="separator:abba1bcc85b8fb7b29cfdb0e60d225774 inherit pub_methods_structt8__crtp__operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classt8__default__scheme__common"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classt8__default__scheme__common')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classt8__default__scheme__common.html">t8_default_scheme_common&lt; t8_default_scheme_tri &gt;</a></td></tr>
<tr class="memitem:a1e844a8f053755b5022e812deeb0f849 inherit pro_attribs_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="a1e844a8f053755b5022e812deeb0f849"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a1e844a8f053755b5022e812deeb0f849">element_size</a></td></tr>
<tr class="memdesc:a1e844a8f053755b5022e812deeb0f849 inherit pro_attribs_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size in bytes of an element of class <em>eclass</em>. <br /></td></tr>
<tr class="separator:a1e844a8f053755b5022e812deeb0f849 inherit pro_attribs_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3655aaa7c577bf21c3c3e2aec755c68b inherit pro_attribs_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="a3655aaa7c577bf21c3c3e2aec755c68b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a3655aaa7c577bf21c3c3e2aec755c68b">scheme_context</a></td></tr>
<tr class="memdesc:a3655aaa7c577bf21c3c3e2aec755c68b inherit pro_attribs_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymous implementation context. <br /></td></tr>
<tr class="separator:a3655aaa7c577bf21c3c3e2aec755c68b inherit pro_attribs_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc4c33e0df7b207b03726c33ed737f8 inherit pro_attribs_classt8__default__scheme__common"><td class="memItemLeft" align="right" valign="top"><a id="a0bc4c33e0df7b207b03726c33ed737f8"></a>
<a class="el" href="t8__eclass_8h.html#a343c2af26e5b41822905b164cab176ec">t8_eclass_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt8__default__scheme__common.html#a0bc4c33e0df7b207b03726c33ed737f8">eclass</a></td></tr>
<tr class="memdesc:a0bc4c33e0df7b207b03726c33ed737f8 inherit pro_attribs_classt8__default__scheme__common"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tree class. <br /></td></tr>
<tr class="separator:a0bc4c33e0df7b207b03726c33ed737f8 inherit pro_attribs_classt8__default__scheme__common"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Default implementation of the scheme for the triangular element class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab844974b36df6486aaac80627b1cd128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab844974b36df6486aaac80627b1cd128">&#9670;&nbsp;</a></span>element_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative if elem1 &lt; elem2, zero if elem1 equals elem2 and positive if elem1 &gt; elem2. If elem2 is a copy of elem1 then the elements are equal. </dd></dl>

</div>
</div>
<a id="a6e531db662a070409a45fc03c053fe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e531db662a070409a45fc03c053fe79">&#9670;&nbsp;</a></span>element_construct_successor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_construct_successor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>succ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the successor in a uniform refinement of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose successor should be constructed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">succ</td><td>The successor element whose entries will be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4024674b091abd09c748aee432d161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4024674b091abd09c748aee432d161">&#9670;&nbsp;</a></span>element_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy all entries of <b>source</b> to <b>dest</b>. </p>
<p><b>dest</b> must be an existing element. No memory is allocated by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The element whose entries will be copied to <b>dest</b>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>This element's entries will be overwritten with the entries of <b>source</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>source</em> and <em>dest</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="af9bbf0e779c377ab4b9b0dace4ebfbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bbf0e779c377ab4b9b0dace4ebfbb0">&#9670;&nbsp;</a></span>element_extrude_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_extrude_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classt8__scheme.html">t8_scheme</a> *&#160;</td>
          <td class="paramname"><em>scheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a boundary face inside a root tree's face construct the element inside the root tree that has the given face as a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>An allocated element. The entries will be filled with the data of the element that has <em>face</em> as a face and lies within the root tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_face</td><td>The index of the face of the root tree in which <em>face</em> lies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scheme</td><td>The scheme collection with a scheme for the eclass of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of <em>elem</em> that coincides with <em>face</em>. </dd></dl>

</div>
</div>
<a id="a4c5e43eb9d545c4385eed40d023e2798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5e43eb9d545c4385eed40d023e2798">&#9670;&nbsp;</a></span>element_face_get_child_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_face_get_child_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a face of an element and a child number of a child of that face, return the face number of the child of the element that matches the child face. </p>
<pre class="fragment"> x ---- x   x      x           x ---- x
 |      |   |      |           |   |  | &lt;-- f
 |      |   |      x           |   x--x
 |      |   |                  |      |
 x ---- x   x                  x ---- x
  elem    face  face_child    Returns the face number f
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_child</td><td>A number 0 &lt;= <em>face_child</em> &lt; num_face_children, specifying a child of <em>elem</em> that shares a face with <em>face</em>. These children are counted in linear order. This coincides with the order of children from a call to <a class="el" href="classt8__default__scheme__tri.html#a7415aabf2dc8d8908dd727fededbf2e4">element_get_children_at_face</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the face of a child of <em>elem</em> that coincides with <em>face_child</em>. </dd></dl>

</div>
</div>
<a id="acc6f2945d5b9305a65f803b965bd8bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6f2945d5b9305a65f803b965bd8bd9">&#9670;&nbsp;</a></span>element_face_get_parent_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_face_get_parent_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a face of an element return the face number of the parent of the element that matches the element's face. </p>
<p>Or return -1 if no face of the parent matches the face. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>Then number of the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>face</em> of <em>elem</em> is also a face of <em>elem's</em> parent, the face number of this face. Otherwise -1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For the root element this function always returns <em>face</em>. </dd></dl>

</div>
</div>
<a id="a9dd03067fd8eba757c06751ea59059b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd03067fd8eba757c06751ea59059b1">&#9670;&nbsp;</a></span>element_get_ancestor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_ancestor_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the ancestor id of an element, that is the child id at a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A refinement level. Must satisfy <em>level</em> &lt;= elem.level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child_id of <em>elem</em> in regard to its <em>level</em> ancestor. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ancestor id at elem.level is the same as the child id. </dd></dl>

</div>
</div>
<a id="a9dabbbaa590723f847cf666e0c463c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dabbbaa590723f847cf666e0c463c81">&#9670;&nbsp;</a></span>element_get_anchor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_anchor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>anchor</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the integer coordinates of the anchor node of an element. </p>
<p>The default scheme implements the Morton type SFCs. In these SFCs the elements are positioned in a cube [0,1]^(dL) with dimension d (=0,1,2,3) and L the maximum refinement level. All element vertices have integer coordinates in this cube and the anchor node is the first of all vertices (index 0). It also has the lowest x,y and z coordinates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">anchor</td><td>The integer coordinates of the anchor node in the cube [0,1]^(dL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac03de1542bc0a9c76dc2f927fe5be07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03de1542bc0a9c76dc2f927fe5be07a">&#9670;&nbsp;</a></span>element_get_boundary_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_boundary_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classt8__scheme.html">t8_scheme</a> *&#160;</td>
          <td class="paramname"><em>scheme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the boundary element at a specific face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of the face of which to construct the boundary element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">boundary</td><td>An allocated element of dimension of <em>element</em> minus 1. The entries will be filled with the entries of the face of <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scheme</td><td>The scheme containing an eclass scheme for the boundary face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e8d868c0980b89507ceb02b63e1ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8d868c0980b89507ceb02b63e1ee47">&#9670;&nbsp;</a></span>element_get_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>childid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the child element of a given number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childid</td><td>The number of the child to construct. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child</td><td>The storage for this element must exist and match the element class of the child. On output, a valid element. It is valid to call this function with elem = child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81a4aaf7bd9f71de748bb638498fdcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a4aaf7bd9f71de748bb638498fdcab">&#9670;&nbsp;</a></span>element_get_child_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_child_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the child id of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child id of elem. </dd></dl>

</div>
</div>
<a id="abc5d668a6269fe8802bc4f133d422528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5d668a6269fe8802bc4f133d422528">&#9670;&nbsp;</a></span>element_get_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct all children of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>This must be a valid element, bigger than maxlevel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the output array <em>c</em> must match the number of children. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The storage for these <em>length</em> elements must exist and match the element class in the children's ordering. On output, all children are valid. It is valid to call this function with elem = c[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__default__scheme__tri.html#a3ab857fe11918a6ad688d8c41f3a37fb" title="Return the number of children of an element when it is refined.">element_get_num_children</a> </dd></dl>

</div>
</div>
<a id="a7415aabf2dc8d8908dd727fededbf2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7415aabf2dc8d8908dd727fededbf2e4">&#9670;&nbsp;</a></span>element_get_children_at_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_children_at_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>child_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an element and a face of the element, compute all children of the element that touch the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">children</td><td>Allocated elements, in which the children of <em>elem</em> that share a face with <em>face</em> are stored. They will be stored in order of their linear id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_children</td><td>The number of elements in <em>children</em>. Must match the number of children that touch <em>face</em>. <a class="el" href="classt8__default__scheme__tri.html#a8c9b54a223b4dbd5c104b335603f74a4">element_get_num_face_children</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child_indices</td><td>If not NULL, an array of num_children integers must be given, on output its i-th entry is the child_id of the i-th face_child. It is valid to call this function with elem = children[0]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62bf4b3ba26704dcb11c472c4682023a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bf4b3ba26704dcb11c472c4682023a">&#9670;&nbsp;</a></span>element_get_corner_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_corner_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the face numbers of the faces sharing an element's corner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>corner</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face number of the <em>face-th</em> face at <em>corner</em>. </dd></dl>

</div>
</div>
<a id="a4f6f24fd0e41e010236e829598b99639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6f24fd0e41e010236e829598b99639">&#9670;&nbsp;</a></span>element_get_face_corner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_face_corner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corner number of an element's face corner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face index for <em>element</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner</td><td>A corner index for the face 0 &lt;= <em>corner</em> &lt; num_face_corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner number of the <em>corner-th</em> vertex of <em>face</em>. </dd></dl>

</div>
</div>
<a id="a758a0209670c6c2c756c6163b9cae8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758a0209670c6c2c756c6163b9cae8c9">&#9670;&nbsp;</a></span>element_get_face_neighbor_inside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_face_neighbor_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>neigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neigh_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the face neighbor of a given element if this face neighbor is inside the root tree. </p>
<p>Return 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">neigh</td><td>If the face neighbor of <em>elem</em> along <em>face</em> is inside the root tree, this element's data is filled with the data of the face neighbor. Otherwise the data can be modified arbitrarily. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The number of the face along which the neighbor should be constructed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neigh_face</td><td>The number of <em>face</em> as viewed from <em>neigh</em>. An arbitrary value, if the neighbor is not inside the root tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>neigh</em> is inside the root tree. False if not. In this case <em>neigh's</em> data can be arbitrary on output. </dd></dl>

</div>
</div>
<a id="a5efd463f38684143c60f062683e1b557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efd463f38684143c60f062683e1b557">&#9670;&nbsp;</a></span>element_get_face_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8__element__shape_8h.html#aab8844a13783f0c1ab05e1d027fd545a">t8_element_shape_t</a> t8_default_scheme_tri::element_get_face_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the shape of the face of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element shape of the face. </dd></dl>

</div>
</div>
<a id="a36c0013033e71c0f28ebed889222dec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c0013033e71c0f28ebed889222dec6">&#9670;&nbsp;</a></span>element_get_first_descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_first_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the first descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The first element in a uniform refinement of <em>elem</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3791112001fb9a8320058d54cb6a72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3791112001fb9a8320058d54cb6a72a">&#9670;&nbsp;</a></span>element_get_first_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_first_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>first_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the first descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">first_desc</td><td>An allocated element. This element's data will be filled with the data of the first descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the first descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ff9d0cc7e39d491538fe8cc1b1d8a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff9d0cc7e39d491538fe8cc1b1d8a7f">&#9670;&nbsp;</a></span>element_get_last_descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_last_descendant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the last descendant of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose descendant is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The last element in a uniform refinement of <em>elem</em> of the given level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the descendant is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f0a052a363e14379e22cf02fbb04716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0a052a363e14379e22cf02fbb04716">&#9670;&nbsp;</a></span>element_get_last_descendant_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_last_descendant_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>last_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the last descendant of an element at a given level that touches a given face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_desc</td><td>An allocated element. This element's data will be filled with the data of the last descendant of <em>elem</em> that shares a face with <em>face</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level, at which the last descendant is constructed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e813fd9281d40f4c14aaf7b061cd6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e813fd9281d40f4c14aaf7b061cd6c2">&#9670;&nbsp;</a></span>element_get_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the refinement level of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose level should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of <b>elem</b>. </dd></dl>

</div>
</div>
<a id="a58df62c19d183229de2b2c63fcdceeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58df62c19d183229de2b2c63fcdceeb0">&#9670;&nbsp;</a></span>element_get_linear_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a> t8_default_scheme_tri::element_get_linear_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the linear id of a given element in a hypothetical uniform refinement of a given level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose id we compute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The linear id of the element. </dd></dl>

</div>
</div>
<a id="aeea955210c542b4d937b8ce8614f8d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea955210c542b4d937b8ce8614f8d57">&#9670;&nbsp;</a></span>element_get_max_num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_max_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum number of faces of a given element and all of its descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of faces of <em>elem</em> and its descendants. </dd></dl>

</div>
</div>
<a id="a134702050c17d4cfdd7a0c0bae865faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134702050c17d4cfdd7a0c0bae865faa">&#9670;&nbsp;</a></span>element_get_nca()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_nca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>nca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nearest common ancestor of two elements. </p>
<p>That is, the element with highest level that still has both given elements as descendants. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first of the two input elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second of the two input elements. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nca</td><td>The storage for this element must exist and match the element class of the child. On output the unique nearest common ancestor of <b>elem1</b> and <b>elem2</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ab857fe11918a6ad688d8c41f3a37fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab857fe11918a6ad688d8c41f3a37fb">&#9670;&nbsp;</a></span>element_get_num_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_num_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of children of an element when it is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose number of children is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>elem</em> if it is to be refined. </dd></dl>

</div>
</div>
<a id="a8c9b54a223b4dbd5c104b335603f74a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b54a223b4dbd5c104b335603f74a4">&#9670;&nbsp;</a></span>element_get_num_face_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_num_face_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of children of an element's face when the element is refined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose face is considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of children of <em>face</em> if <em>elem</em> is to be refined. </dd></dl>

</div>
</div>
<a id="a4d048afb1db9ee454f6caa7fce91c254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d048afb1db9ee454f6caa7fce91c254">&#9670;&nbsp;</a></span>element_get_num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_num_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of faces of a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of faces of <em>elem</em>. </dd></dl>

</div>
</div>
<a id="a5fa56c7a46cd8e8e810efcb9b7d6143d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa56c7a46cd8e8e810efcb9b7d6143d">&#9670;&nbsp;</a></span>element_get_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the parent of a given element <b>elem</b> and store it in <b>parent</b>. </p>
<p><b>parent</b> needs to be an existing element. No memory is allocated by this function. <b>elem</b> and <b>parent</b> can point to the same element, then the entries of <b>elem</b> are overwritten by the ones of its parent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose parent will be computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parent</td><td>This element's entries will be overwritten by those of <b>elem's</b> parent. The storage for this element must exist and match the element class of the parent. For a pyramid, for example, it may be either a tetrahedron or a pyramid depending on <b>elem's</b> childid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35adf980ecc3a6657bffcc38be7da96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35adf980ecc3a6657bffcc38be7da96">&#9670;&nbsp;</a></span>element_get_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>ref_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points in the reference space of an element to points in the reference space of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_coords</td><td>The coordinates \( [0,1]^\mathrm{dim} \) of the point in the reference space of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coords</td><td>Number of \( dim\)-sized coordinates to evaluate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_coords</td><td>The coordinates of the points in the reference space of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fbf46899d79c103d24b9073fc3dae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbf46899d79c103d24b9073fc3dae27">&#9670;&nbsp;</a></span>element_get_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sibid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>sibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a specific sibling of a given tri element <b>elem</b> and store it in <b>sibling</b>. </p>
<p><b>sibling</b> needs to be an existing element. No memory is allocated by this function. <b>elem</b> and <b>sibling</b> can point to the same element, then the entries of <b>elem</b> are overwritten by the ones of its <b>sibid</b> -th sibling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element whose sibling will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sibid</td><td>The id of the sibling computed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sibling</td><td>This element's entries will be overwritten by those of <b>elem's</b> sibid-th sibling. The storage for this element must existand match the element class of the sibling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9267c67356ba53d1dd4ce6119328d89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9267c67356ba53d1dd4ce6119328d89b">&#9670;&nbsp;</a></span>element_get_tree_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_get_tree_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an element and a face of this element. </p>
<p>If the face lies on the tree boundary, return the face number of the tree face. If not the return value is arbitrary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The index of a face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the tree face that <em>face</em> is a subface of, if <em>face</em> is on a tree boundary. Any arbitrary integer if <em>is</em> not at a tree boundary. </dd></dl>

</div>
</div>
<a id="a6b1483034161e1f0e707b2ced8047a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1483034161e1f0e707b2ced8047a00">&#9670;&nbsp;</a></span>element_get_vertex_integer_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_vertex_integer_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integer coordinates of a given element vertex. </p>
<p>The default scheme implements the Morton type SFCs. In these SFCs the elements are positioned in a cube [0,1]^(dL) with dimension d (=0,1,2,3) and L the maximum refinement level. All element vertices have integer coordinates in this cube. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The id of the vertex whose coordinates shall be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>An array of at least as many integers as the element's dimension whose entries will be filled with the coordinates of <em>vertex</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f4df1a120a1a623755f540c2aa57e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4df1a120a1a623755f540c2aa57e60">&#9670;&nbsp;</a></span>element_get_vertex_reference_coords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_get_vertex_reference_coords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coords</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the coordinates of a given element vertex inside a reference tree that is embedded into [0,1]^d (d = dimension). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>The id of the vertex whose coordinates shall be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>An array of at least as many doubles as the element's dimension whose entries will be filled with the coordinates of <em>vertex</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>coords should be zero-initialized, as only the first d coords will be set, but when used elsewhere all coords might be used. </dd></dl>

</div>
</div>
<a id="adc89b85c198baebdba5067c3239ee7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc89b85c198baebdba5067c3239ee7c6">&#9670;&nbsp;</a></span>element_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an array of allocated tri elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of tri elements to be initialized. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>On input an array of <b>length</b> many allocated elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In debugging mode, an element that was passed to <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> must pass <a class="el" href="classt8__default__scheme__tri.html#afb699e44f0a6f62397cc554e5d6dbf07">element_is_valid</a>. </dd>
<dd>
If an element was created by <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> then <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> may not be called for it. Thus, <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> should initialize an element in the same way as a call to <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> would. Thus, if <em>called_new</em> is true this function should usually do nothing. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d" title="Allocate memory for an array of triangles and initialize them.">element_new</a> </dd>
<dd>
<a class="el" href="classt8__default__scheme__tri.html#afb699e44f0a6f62397cc554e5d6dbf07" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">element_is_valid</a> </dd></dl>

</div>
</div>
<a id="a3c67b99ef314de05b75d4bc946b8f8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c67b99ef314de05b75d4bc946b8f8d7">&#9670;&nbsp;</a></span>element_is_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two elements are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem2</td><td>The second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the elements are equal, 0 if they are not equal </dd></dl>

</div>
</div>
<a id="a2a256aa53bdf0fd5ffccd17421bc245d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a256aa53bdf0fd5ffccd17421bc245d">&#9670;&nbsp;</a></span>element_is_root_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_is_root_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute whether a given element shares a given face with its root tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The input element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>A face of <em>elem</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>face</em> is a subface of the element's root element. </dd></dl>

</div>
</div>
<a id="afb699e44f0a6f62397cc554e5d6dbf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb699e44f0a6f62397cc554e5d6dbf07">&#9670;&nbsp;</a></span>element_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::element_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a given element can be considered as 'valid' and it is safe to perform any of the above algorithms on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>The element to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>element</em> is safe to use. False otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>An element that is constructed with <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> must pass this test. </dd>
<dd>
An element for which <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> was called must pass this test. </dd>
<dd>
This function is used for debugging to catch certain errors. These can for example occur when an element points to a region of memory which should not be interpreted as an element. </dd>
<dd>
We recommend to use the assertion T8_ASSERT (element_is_valid (elem)) in the implementation of each of the functions in this file. </dd></dl>

</div>
</div>
<a id="a8390fe7d224f7b1ac3886a355a0d2bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8390fe7d224f7b1ac3886a355a0d2bd7">&#9670;&nbsp;</a></span>element_MPI_Pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_MPI_Pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **const&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>send_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack multiple elements into contiguous memory, so they can be sent via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of elements that are to be packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">send_buffer</td><td>Buffer in which to pack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac541e20ae579571247bd11c6872cfdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac541e20ae579571247bd11c6872cfdbd">&#9670;&nbsp;</a></span>element_MPI_Pack_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_MPI_Pack_size </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine an upper bound for the size of the packed message of <b>count</b> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pack_size</td><td>upper bound on the message size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682a7f24c38380acd4d60db22da3205b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682a7f24c38380acd4d60db22da3205b">&#9670;&nbsp;</a></span>element_MPI_Unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_MPI_Unpack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack multiple elements from contiguous memory that was received via MPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvbuf</td><td>Buffer from which to unpack the elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>size of the buffer (in order to check that we don't access out of range) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">position</td><td>the position of the first byte that is not already packed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>Array of initialised elements that is to be filled from the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to unpack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI Communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53a6220d0d473947eae19383f309c85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a6220d0d473947eae19383f309c85d">&#9670;&nbsp;</a></span>element_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> **&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for an array of triangles and initialize them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of tri elements to be allocated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>On input an array of <b>length</b> many unallocated element pointers. On output all these pointers will point to an allocated and initialized element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not every element that is created in t8code will be created by a call to this function. However, if an element is not created using <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a>, then it is guaranteed that <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> is called on it. </dd>
<dd>
In debugging mode, an element that was created with <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> must pass <a class="el" href="classt8__default__scheme__tri.html#afb699e44f0a6f62397cc554e5d6dbf07">element_is_valid</a>. </dd>
<dd>
If an element was created by <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> then <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> may not be called for it. Thus, <a class="el" href="classt8__default__scheme__tri.html#a53a6220d0d473947eae19383f309c85d">element_new</a> should initialize an element in the same way as a call to <a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6">element_init</a> would. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classt8__default__scheme__tri.html#adc89b85c198baebdba5067c3239ee7c6" title="Initialize an array of allocated tri elements.">element_init</a> </dd>
<dd>
<a class="el" href="classt8__default__scheme__tri.html#afb699e44f0a6f62397cc554e5d6dbf07" title="Query whether a given element can be considered as &#39;valid&#39; and it is safe to perform any of the above...">element_is_valid</a> </dd></dl>

</div>
</div>
<a id="af010d4a39286135ee87e46326e79c818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af010d4a39286135ee87e46326e79c818">&#9670;&nbsp;</a></span>element_set_linear_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_set_linear_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8_8h.html#ae5c6845909c4725136233464e6db11bb">t8_linearidx_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the entries of an allocated element according to a given linear id in a uniform refinement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element whose entries will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The level of the uniform refinement to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The linear id. id must fulfil 0 &lt;= id &lt; 'number of leaves in the uniform refinement' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1199e2d12da956b554473273677b26b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1199e2d12da956b554473273677b26b4">&#9670;&nbsp;</a></span>element_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>debug_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>string_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a given element. </p>
<p>For a example for a triangle print the coordinates and the level of the triangle. This function is only available in the debugging configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem</td><td>The element to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_string</td><td>String printed to debug </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">string_size</td><td>String size of <em>debug_string</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85425ac5930a92d365f83968f4bf6135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85425ac5930a92d365f83968f4bf6135">&#9670;&nbsp;</a></span>element_transform_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::element_transform_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_smaller_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suppose we have two trees that share a common face f. </p>
<p>Given an element e that is a subface of f in one of the trees and given the orientation of the tree connection, construct the face element of the respective tree neighbor that logically coincides with e but lies in the coordinate system of the neighbor tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem1</td><td>The face element. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem2</td><td>On return the face element <em>elem1</em> with respect to the coordinate system of the other tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation of the tree-tree connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="t8__cmesh_8h.html#a7a3c52997f3d6eb9d02870c34171693b" title="Insert a face-connection between two trees in a cmesh.">t8_cmesh_set_join</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>Depending on the topological orientation of the two tree faces, either 0 (both faces have opposite orientation) or 1 (both faces have the same top. orientattion). <a class="el" href="t8__eclass_8h.html#a62982c7b72a0ab0b8d836beaf97bc430">t8_eclass_face_orientation</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_smaller_face</td><td>Flag to declare whether <em>elem1</em> belongs to the smaller face. A face f of tree T is smaller than f' of T' if either the eclass of T is smaller or if the classes are equal and f&lt;f'. The orientation is defined in relation to the smaller face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>elem1</em> and <em>elem2</em> may point to the same element. </dd></dl>

</div>
</div>
<a id="a41ee998b536f103d72a7a64a260eb923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ee998b536f103d72a7a64a260eb923">&#9670;&nbsp;</a></span>elements_are_family()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::elements_are_family </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *const *&#160;</td>
          <td class="paramname"><em>fam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether a given set of elements is a family or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fam</td><td>An array of as many elements as an element of class <b>scheme</b> has siblings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if <b>fam</b> is not a family, nonzero if it is. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>level 0 elements do not form a family. </dd></dl>

</div>
</div>
<a id="a24dd1210c84c61290fe896e7fd7d8b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dd1210c84c61290fe896e7fd7d8b6d">&#9670;&nbsp;</a></span>get_element_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t t8_default_scheme_tri::get_element_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of a tri element. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of an element of class tri. </dd></dl>

</div>
</div>
<a id="a3f00f65c7feb8af5f7cecced39e98bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f00f65c7feb8af5f7cecced39e98bab">&#9670;&nbsp;</a></span>get_maxlevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::get_maxlevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum allowed level for this element class. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed level for elements of this class. </dd></dl>

</div>
</div>
<a id="adcdc95dba298093d67fc25120f38a240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdc95dba298093d67fc25120f38a240">&#9670;&nbsp;</a></span>refines_irregular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t8_default_scheme_tri::refines_irregular </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if there is one element in the tree, that does not refine into 2^dim children. </p>
<p>Returns false otherwise.</p><ul>
<li><dl class="section return"><dt>Returns</dt><dd>0, because tris refine regularly </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a478e2ae136bb44993533770f34a2b52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478e2ae136bb44993533770f34a2b52b">&#9670;&nbsp;</a></span>set_to_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void t8_default_scheme_tri::set_to_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="t8__element_8h.html#ac4c605cddc1aad4d36398a773768f738">t8_element_t</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an element with the root element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elem</td><td>The element to be filled with root. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/t8_schemes/t8_default/t8_default_tri/<a class="el" href="t8__default__tri_8hxx_source.html">t8_default_tri.hxx</a></li>
<li>src/t8_schemes/t8_default/t8_default_tri/t8_default_tri.cxx</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
